<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ad09b3fc3371368329565ff0d487d2f4737db4baf8e3b50cd70f0ebb0d1af51c560db646c6828ca9e76439c45482a1e2881cd91a9e2f9c40651835d09e79116a21b64fe35c0d94c5ac2e7c8cd4e1cbf81ec9e5370ae772f5a9d76ff5d5ba938dbae908f9de6273c92f5d5402d4665f7a27f7a95641d969022502e8f88d95ef77fd82594a628a93bca394fd95085d43acb6f8e6ecca831d0b3b312b0a6fddaed30d251af2df4728ef1c904ff2684dc42b3ad86aebafe6d2be764161b780e394006ca8f7909b18e018ed75534192e82996100ed5aabe7f4567ffa83a3f6f77149a16d5131611825ea39750197971f7ae9f661a01eadd35c739d80c29ef32895e9ece9e4d9c2efa5d7c2c32a3043fb8c0581aff2c857be82841bcbbbc1c9bea946eacc7c239708868bfcaf21c193786a1bc47f525520c24c0dee75c15abfd7c75ca7b02852b57fdfdf0d83c191cbf07fd2128026f6539b49344f267d64296035b0d774eaef67dc452fa98f47c8e95f15ef2b254e5a712aeed65f12780f685e334ea077791368dd9db3f6101bf03df75ce3ba39562b5bc38828f1e305ed585acd12f01ce7c0f84dec5c4a3b15fcc81b4c6f128ec2acb282f30033ed9a954867741a4ceed077d4a8d8f77feac76a159092d5d6b7b923bb46f6d8784d2ac0fe96e5cb9936b2f4cd7a4e9c0ef8e0971b28df316c32446937f9c97af9ae8bd9fa93c7636727f933461a9bf097f81e223c84c4052e9fd6138ba809bdb615c6954e55f9372aab9377b45f117b0192f7002e1276c4d414c0a25a75e36e5e99cd919de503c68ffb1f1a9ceda299c1224d74eb2521032d0fc1c3c9065d0ba521c3947dd09f303fbe28ae419c2297c56839337ff17353057b28b2c917f61906e6cb206977371a9ceadd65d7aed1dba82a3826191a53cf91d138c3ee80c9d2a59cc745f17f56d319cc48cab693e00979eb3fa99be3927cd536c2fd880a22424e8f6e9cc846511df76cac2c2170cc1d0eb58bda7971182c26faefa62ee68b6dd65a96721c83216ea8db4bf04d786df969691f76a2f1e6c75f93190ae4854d2ad8fda6a6d4be916bfea3bf3460fb44545e6912b9a8eae51c209c06f7fdac9be1781676ab1b89bdcef75ce67eb575d1d6edb3af8ec96b8ce1fe640aeecbad4297d3035ededdd0d529bcbed97b3344bb35cc59993e9839dcd28f1dbff6acfe4cb7811d0d02834fa6f5256eee2f0f0bf54f01f0a29a6b0555c112920b8e8b6e853aff109ee1895a1bfa85b3bc3200ab8fe1658200d620984aa9a46646f518428db79cc3c3f82c58872c714598e4903571fc7e01f2d60c441619f791e22bb43c78991f5b097f3e474c7fe96bd39261d4cc7fa029fd6dd80f7639d76465483304287e10bcb2779ddbee8c7037247097f9d9f1f522942955eedc558ff6c94e2713db7177d6c8c2eb65e1b9f99d2fc082d5498643ace3ea8caa366b08d4e1bfb4bb06781e78f63593b618a2161cd1b5ec6b4f3d5094a042326729a01d708b0b673b26d26a8c883178daf91e172c71c31b11bfdc3f52e59bac5f141671f05db59e703cbfed779bdde702fe0ef4d1826ccd3cef9ab2f9812848b8a050d2fefa70599a90ba1aada582a883fa12d1192aa431bf81633c6c68870b04442891a2be69389ff9fb5f35b95beb0b0bd504494c95870088e60c66c7169befc92c694880279abaa281ac0791d8d009fb9cc440d83528ae2ace442d5b4510b76d2e7d4c0bc76ecf1a8ae60b26f345b88ebff3932b7a2ee7ba5865a0d7ea6ba63b64a364b5e96f1a4557d49b6d468a7d084ca51d4cb6f17a00434d565a62b70ade8aefdee3215c3f14d21e2119665a3c783bbc64dfe9e9fe2ac07cd57e51573682db259e2fe2594e07ad3ba21347cde93dfd5682acab9ce8de378c151d9f86b7793a9c69098eb63e06e678378e2b9d9c2299c13bb6d059b32a97af456d457caa4b64285cc2392f3eb87ff1fbd66c726aac40628834714b9f759690fc98569a45a8f3b6028ca2a7bbae591bc8a289e04242c5c3060ba8da0e7c3c143f094c5cdfaf302e86036b618cb44d662b726fd808d763a4ca886adb219d6222a37cb300c0aa5255b25547bc9d8b009be0c48e94c3b7fea9fd2a2edc1a1d5e358fe7cb241a1cd3486d43d6f5e37d63f6b8034908d5a36fb3a1acc47322cc69ddfd056a13b0df83d790bffb473bfca205e5db327344a84fe9d5a15d28a5bc5ae747177f8f613a23b7906b1ba61671d99b6fc77fbed0461e5002b61ab3a1ba6fb282126b9a8cf55322f2da86fe84a5a4bc92041588e6be7ba8e1c011b29336481dc2f413d10d19ac86fcd5b4b820d84a523605d6b964e4d132e1daa5cdfc651acc3cce7099b2a6f0928f47370f19f022581d0e80fbc7beb26f872a0ce4777cbd1f8f714b012456f2876b9e3d30421c3bc508068c240554e8d763b00e4626828206ea268833ed6f44175f6462081815caa58fb40f5ddfc00f6472f179ea0681808849a4e3f39e9a83d2abee49983f7e8521cfef580ec6553477cefacc761aeb50115d512b4dcf227bd6d9f83a943a431f51e1e01257e98aa15817a789555ffc10ce89601ccc3cf8bd4df3ced5558765ad64fc3613edb4bb22e7d0ab00380979e9feeaf2d58fa78f6c0dd769621c15e3d17764b5a54bc4cbd04c8b36f02493d7ef7ad5bdc541084fe15acf15995375fda9ae333ac56775196cbec07ef1c62d9bf28e167a4f32d140fc59e000fab7892c8bd268fecdde18350ba0c9d7749c395f72786b46d2631c6d8c7fca47dbfb91c56ee9b5992b187957ce336c6e49c9ba1d7fb115c3874f6468ac6c2af5399e420bf41d7a011d33dd9f68777733da386500c00849c65ecd13dfa87e60bbdcbe8c86c551e8ae2b524ded9176417a068303bad4abdb7201f3e621101139fd01674c320f5cfa455abc6819bd87569621680d4fafaef8915bff67fd0182388e0b83fc7b900f84f314b2be766b33b7d9316efa98a8925b16c16a71f2fa4d0711c7627989677e34102f78ce9ab34611f04ec9917f2b55d65153e655382db9693e14ff3e607cd07c9b8f6a8fc77d56e4ddab24c2960763935c9bb457e4364e9437df9ae918ff331523b59523bbe8d797c21e31c9e6ccacaf9d9b489d66f04fccf726b0b7caa972112a77048fa4358f2b41f06386893ba98eb3d0beafa437859ce40fbe41d8aff10e2fb80a135b477287a4cdf5a999011c55df5c3a4745f3a0c4cdffbb98eb62c9a752a12e083212a63cecb7a3434b040dbc1463639578db3c848a394b2952a157315e8190e6d74233e8582580510b10f80c560ae830c0fd1b493818f8a7b322a04e6e79f8c56be2d9a9f0e0c6948705b2d171922df6757cabf928aff6585db8af423b86291638a875f91e714bad13e1a2914ea27c4ad5b9936877049c3936e45b9c1655132448eccf6753a895bdfea3521ce7616961c5876be4c49c9f777702aa5191e6b959a9bf82c91982b3c27946c06e4d4f08d5bb9e6dd924b43a99cb7e7d762a555f8c701f2d6fde3dbb1378abcc37a7278d904c6b6f48bb1022c2fae321423735c4e6229f47ece5170857695a5d369860522d63d3df369f2f4c9e73034136b155eee70d43951e9ae787f615161ff94878529ea66166a5915df9338578387fb8a5e9024065d3f906808b72ac9822b80b7232eb56ae0c94d6a7df796075c5955dc2428653c69344f40d98d15413965e297fa85c37a19778f53429f714cbc7601a110fec2803cbdb07043a6ebb549705ae89e90153708a5ac5b8e9eb4304138f4646709faa0f419206a4b1994a49f3d921a637c67bd6054e4e1c4dc306e64e86ea80cac2ededac146d625a09ff0bb8bc2a2a1f29490696157b41c2bc1e5b2db730fbbe914957bbfb3dc6e58d84d437652c79eff2c4331d1fea90f3e34025d717b724edd94bd9684502c427b8d9908e000d95c5963b00629b7cea4294e610b29630adfe4c1f19ac6c41bf65707ff4871a981a55e66c43e8d078ad2e9dc9954a258bd7b7b3fb6b05d0d7e116686e928560262046d1a3053f245c5c40b0573d55d0577334d4bc094a29ddc3ef67eba5dbc4d13d12bdf73023751ee2ca93c17f33749a3fd44dffa1328f48787f339878035c3f2947e10be7f4292adbdfa7f7a75938af3243048ca07f456a70c9d729b70ffac7b8d44bc6a8fd4d29b1e3306c57759df1bcd00caea72a62acbd2bb1ea95e96ef464d58641455181566026b18279db024f80da9e3d063d7ac18a891db5eaeae4133b95aa767d811912cf559845b26d0d8dca28f0586890f0356acc94c2e4835ee39cec72c0407f42e5ed78d6a0836a22d3dfd31738a77e762668eccb65123cd71155998954de64c920bdec057e2d6b4f62f80ae9f3e86e48c5912bf6a0e5f36e855082939b2a5f856f29385e585e05ed62f2c9b8c9f5eb346742ccbe09fe0dd6b8248128ffe95014988fe45e228ad62f2ad2cf93535d05fe09942595ab54e81420a374aee6aa8d44280c23ddbd7149e0b8b24d44ab56df917e4f727e06eaa2bde9acabe5d8cb8de4db83ddff725505436d09df18e1c9515ea3b354cadbb34011d02668515a69dd91296c2323adfca86a72091cb23a15e049ed5b7a2a2475117836e4d9dde2683459c599970b0ff7da93295148bac30bdddbfc61db10fcc47aeb3b038c280e47f83d32dabf45650b925ec1b9190e4e7267e40029dd825fe641caa9edde1d3b1eebee16c2332810c490aa847ab366e35ed9d6e1c8ee06899f66bf02740eceaa4020e1705406b8aea1994cc36e4c1ecaee0b87565f89d145b2b670c17a7a6d5417b418450b3fde278a335d773344eb62ea27eb7bb7a6df967aa18f5ba017fe996aa31a4bd51a18bd184ef66954d3aee006f60bd374b860fe246168b0614e16fe3bb6395ed087bd4fd6617a9cc4c5e0ad0fdf8d33043d9fba97d2f3336038b67bdff0dd7f4a2952111f8e0bb10d7921482021581b960c13d27ac7fe7fa60a1161d88ec55e0517a072009c9ef93b05b93e31b27ab4060e88715ed7717a17a84d6a62c277e5f095612dd16a9e0f22d2f320ed2703a85418ad4ba4148ed2fac38b980de9f97440754d1601e7812d6916e8578ddf109f161bc9ea4c73126022fddf41334541161cf061914952f8910f96b66154e356cf6897b0f2d0af4ee6beea976c101ad29abe7e924631a5f5393b413f00006545838a7d5ea79d62f0f3400a09e9cfaf0dae20d4f30ef2b0935f4e2729bb7959f48cb9d961c986f63add57f0ae5f2985295d35040c4dc08f662bd1b5fbdee9704fc760736db054deb542fa49b1c361d2c8585cf8d8d9a6ec728a9c1b174a8abafbeac5ba9b9737d48b15760e81043235c7b0c5460f9d5b6c308bf753376bb90772d1078c5950f81776764a726321c8492506e7a2dd7fa7d1fdeb04454e3a9d989ebf68fe3cc2ad734327a798bf6645b59385089f4fa607199ea56038ac20251a7a2679329c55323bf70af9e9000057c392b28b1dc41ff3779a23b3dc1132737300e14b10c8bd0885b0c45655cb5b86a090abbf2faf22e263641d2b53dcab6404a37c5e3388e81b169fd503ac5a715b2d896eac0eed36d0043b1f6b20a4dbfd7a0e56c0d9585b72c540dcab7bc8c9a7ac4b90e08c8585cec0d065ab206677127227e2a35216e14585e0cfb3acdb532af75fff8cd132c95f913ef65d92e23b13c427e20a53fa1542090d4f4c86803bd6d7f4bcd1c14e695e72afa3c3f3be87b8fb0cefae58d3d390c1f03afd6e2462e231ee6cee49d61baa0a5ec146d82fcd674ddd16188e2e2bae31ef29b7d465bb0006001832295a8b2d8704d3e1e889d164c35cfb41d9fc158f3b9b77b09a4adddb587e11d473ef35defa5d55d0551759da7de1364d86d72d502825f2f162c3b5bd6d11d7e87f78dca3370fcd7089428b2e96ad6fa3fbf2f23d4444094b66276c1b347cdac66265c948a04dddb41356b4204fb0005cd79be8d280b45dde52ed9e128e92cea4b42c86de057effb64cc57b996d9f5161e9e9429a333a4f8bf2e100a82d1f81e3fc8f8e1b85470308910064a227f68ce995988b31fcf7b09d0e64f2a424f829af03322b9272d6a0d38d3ab3d566e99a47348699ca4135b149606887a33dd4c9db3d7875a31e40a47f1c3a6f3cc60cc2b02a3724767cadbc94b525d31125d05515a4307ccef3e90f7c064da23c76c6b68d2190c1f5cca66f4c072993dcc4f5166bed0b2279d026e268d8040635653f50f853dcab42a780c26364f16eaf4923a82df358ed1a523854cde8f72e0ded56bd1b60047d9e2776040705c04217df07728fe0b9d2a66799c3ae99613d077a1959a830a956e27b28493bace462a6a5251d9faedb7e6b841735bb83978f7e1309614172c19b23e345175c3e2e82970f488da39aa58db3be4f45d0903de6e398ec5b50be8f10aa79811e10f0e707e70529d4b02c04650da65e0c1dc5dfdaa22444fb62457b1524f278fa525f61634999ed6940f9646b550a7afaee4002a628f32cb5d16d50c6972359ae7a2ca2697be8e0bcb902a21d185014b184e1bfb7f7e3adab0d8f083428e94e2ef846f217ec8f17fab56fd4871121780d5bc8f5cbe46ef07dbe039d2815dfab7a6479a65611d5ac4fdba1e0f2fab8401ecccd577710ed8eedb5f77de4924d083e7c1a7e42aeb5cfe3c1325ec998e150929523f1e1ffc18d0c72a21e69c4ad1cef14a26c84d7ba50e813827b57c073d03f936ef7b5a0fe4f16dbf116800cbc0eb8b5ea3ff949625e66375c70dffac5837df770bb0c56907b6583d09922d29dcd1e3453c60cf2b4f6aa2c7f67dc4af2890db82922e4b8400d85d81e3c7aff24185903704af82da997a405f94602376468407e4e58b38327bf24d52740710b7294b857b4cb3a075a40f44c39a085e5f6f7fef4116864b32c8d0f41fa230dbb00b05e34de6f6b01907bfea1bf86aa2519f4a42d5f9ecd0ce95e0fd22a0b4f226084f7aa38c366c2e8d8b6c456b4f1521a8ae53cc3ad4fd409b850760d726ae5aeb0a3535eb1c8922ea81056895ca758e54b6eb705c5b65f01e9c010e3533e1dd22bc4b0f6d6129c59c064f7b2a102f988c4183ba90586c295526fac05257029b74e4532f11b6d1124c47985718fc85db43679b5ed7c7f062a0a4925d7f53ed84c3ce7b62e1b478af740354b63aaa1b268ef649c11e92de8ac347e27acc8c906f4fd048f2e96bca03500a995acd8c6dedd70c4c3bb3de646b4bbdcb329ed51531fd385c5ff42e9ff0ba74f1db43092b2d9aec759ebb6624e0a0723f4e8134e5a0902b62ea7af6f037ce48c3451f26e24cbb137a094f5643017e1aa73b6526fdfe2476c41a5087a93d6694b31c00fa4176ca1312de0c9485338ddc954c35d9b339aacf5043766fe7bf10c333c3dfbd2de1df3374c34147208c020237db9e14340d5200e2b3700aa275d4c4a9663dfbfd2bc025ecb1875dce2275424cece04216a25290e959071d64f929abde215ce1a714f25ffbe2f6d81b0588d9f2ebcabe989ec94e4100601087e834b7b69e54f67b0c45cbf15776f4e941b517a62a6251bc6cb6237c1d9fc7781e98a1e3341194d2c79ac63f2d6eb54c5cf7f4d9696b5f0dcdfa9b4b79be17448b1d70349fa8d775cd1ce5dfb0e090bab8c807c1f0c45aff8a563efead31f68040985aa8ccd37a79d90188ac76c11cdd77324cf2b18bf8cd4f1bbe0079e672ab753f553ead08cadb737bf7707d466e0f2a7d0aa5e58401c831017b73f53e6c1ce763c408836d9445ac87d2bd157eb9011b0715248bf2b31d6ac8d22d7887a52fc17021a12daa38971dcf91a38506bf22656d11e3a115209854777d028ccb8bca4a37befb0932f587685b2c1d000f62f286587db4fd3444679e879642d9a49a60f5c2f89397a0aff7cc87a694a3811bb1f48ed2b5f8bed48ac0da980c5405045858f3b21d45fd5d427d1c61dcf7144c261c20d2a8cc46ce5bff4f84d6795e1c2b853574e7068156bf7238c4b880b452e79a805c63e7fed24be193c396d55b26c3c69453bc1c56e1bc9400c225ff155a4e7abdf92114d5cb87c5295eb779cbff284cdf546fa9787b027c04df04c0517cbe4b2731bb623eaf85e96b0e7ec2f14c95e3ae49ba712c19588095d05fcb90dd2c3987ed786ae502f2b44de8e383aa6c69b9e79088d4ec8e4ec7dba41da26f97b2d153abc9a756d42b687b209f933125765229b4fad23e445ed5e4bf23bffbe441003e976f27d4174dae39127576b1853f734c59e274e645e9a350a6eb36d7bd6633c3f530b82b7411c5193b83465e85105f4cfe271936e5e0b749f7bf58fcf340f0ebf6be394dedcef6b5690da22f0dc145d72aa403d1385808638eeeca9f80cb9b5e0f515c3983268818d3d796a95e067e15f38ecc862c77c3921d52d206d24c826d925b67a61e7c28312e8c0929e1e630eefb34fdb22529c353615cbad15af8e89e34ccdce2a7b610936c76d7b708d9824707404f2052dcf87b278f2199437eb07d61c95dfeece213ae5df0cfa4774b22d858d272bcff62ed1e9e427fcfbad0f837d9e1fa7b46a7b87e02187f5f12ea350ec95d1575de778265820aeecb9e8cd47cf2bdb399d12cf0d3432262ea0786956d3380a6bda1fda28f8217c6367fb9d3008ce1fd806ff6bd6e07423a303b974f4423025c547b3ad5ce605d1c4b61eec04712e09f9e0ef2884cf7fb6f4ba44c5f2bf5e921c13e2038d5849ef8d783e4123e3ec4a7650899d0837b758be90984c14dcfbfd04158a58fa757af1fcbd9f3ce4c034d67d007f53a892893725bdfe253c910eade1717511514279fb1bd20c4016588792c7c4cdf86f3e654b4b048cf6673f0a728f4194e841fcd6ea9a9bf3899ede6b81d7ffced9c9819d7254ffb7bc43c51d4a15500851d3d5dae76011a0b23c12d40fdec3164a64e05a9d76035a58187b83e2de58c51a73344e198f55885a4f440913fadf719cf535f83c0665c29974e4407981c7f1989b7b94c841db1f6f1b50d7f9dd102eba9059ca66753422753a49146d52e542ebda45a5afb5ffaffad6ac3c18a27c2e78f03e90a9956be8e460eefa014eccf72ae16e881092f65b7a9a5505f37323ed9d9fd6ab2f11b42f2c92937803f5bf5a67577e39a362b43c0b506d390f4c9707ab672d3297e18e2e3f6fd2c4fd38711d39c50171e82ab1292c77dff97d56f57a0dc34d705779a0b34a8443208aac9c2a67520d13c7acfb923e4ee95870cd20c64d35b466b1a9412d66254ec3506758cfa1d09c1c249c7e5201440ffc0c808977492c02923f112ff2b7634ac70326c3c2e3dea72710c36f0378c7ff36f5b6beebfca5480f424ba7df22d977957c18f94dd36e1b6b235b2f669edcda3d94eed7fe5d1feb7bbb2e13b76e7d31d2356e4324c8fb74bd472be79e2c6145b44501682f3982f7c3c92cefe0d98264fec7a036981a62eb4ea44efbfaca549fff44a3fb058aa87acf3525c61076385abbad7f0782f6a2ff29972f4c36827353f3da34ccbda0007d2bdba1da3d3c4b51ab20e27c97bf552ff11482b8e6520f08599018264ede7f4b11fe877c1782d85bb90264e5f46c3413f71933bcc257b243134bba86efa6cdfb666f82b7d22e61d0a4ff3e5d5df80ed06bdb8ec66f6a779a95e8371923eadb9bb5860754cbda13441fb8cb3ec424661d4f4d84e23c94283e7ac6853053781a32a3872fab9fed9391965c3f3854966aca79ec1ce233d7883af112759ce5e8a015626eec6dfc68473bb4744028d11b01de6acf2a6ad885e14f71f8aa30b2e455d3e2fe9d02c5ad19f04995a2f59f4c773e7398cc765251ebccac28c9013d997760bd660f1df2a5412d63ded418c311eb708aeb00199bf6ee03daf1f0f98f117644b78719f6d7ca255bbc1cbc95d1af5f3e5e22b5ec43bc3447bb2ec9bf45671f18e13bb94fbb52b3cac85de8363062df3b4c2ebd67d3c15ef2293596903b1dd7b207e1b55046ed82a4cab26b70db905fc63e8357c91dde4526eb150c8dc701634582a309c43fbc28371f6d9f5b24a4bce43ddb900500b1a874f18fab4f6c60b0662c246943644219eb49c38bbd1d9f07e79c56190b776231fcb15a7d6e9f461e0b1180ee39491ec6f66322f51c707dac1cac8e9621f381565834fe37a7cc624176a40845851d4d57538f83bd8c8e885afd5996f20d6933d40429b49bee217da1c2e82da6f3fad17cc1a2e7635a9825bc024c5b0147a00f2683cba6bff6725d526e83c8e828c186baec9d2098da4c6baf2ba61df5f807883931cc19e866dc5f63ad63634402349e134c8f92ec69601b8a416f4e12c5d1adff9e525f999581cd103d2488c954be947183800d49c6fecbc0882415db34b39061c9289ec664e08357c1b6fa75192bdd9dde9e4a9c5485fe1d8d3861c9e8832c72a74a4c8f076cb3a24803261bfd3ffc7d83eec702aa3e2a4041461f029ef0c339d80e0140a101cc2538442d08d1b1d1b434589bcb61ab654f67e32f25d6efdd721de695c2b425a69874a965489e31fc446660c936897e498d161004ee4dc5cf7f0df5fdfc7d2bbf80489c20727df835972af529d6fe979631006bf17dde44097fc988ed58ff486d02254b9f69bf48fbb9886ab684ccdb6e982a256088fa8c5f653abdbe9abdcf1c48cf9fcea34f6bbb4569d3bdf92ee9c5ce5b54c18bf98fce19c39a4d4938a4c9b3e7c371dab59134b8fc8e051569367870a58885b610e546e326f3dbc95a9bb14ade07bc2a5a76e51bba58f8107a1c90998003bf3a49182b47979197a999c4b08264a97eccbcac2a2fd3d7b1e9e1eee706a9e560aa3790741d185374f63b5fa8eada66215462e945b09093a7f2a72808fd5807e77929e6395da1429414304d4698b4f6a804082f01c9ef3552e13ea9d17eca9a1acca542ec78161e0d309ae547f6b689807bff69935ee6204f3fb47116ae6b8a2a9479e9cb381fc0d967505ee8a9e91c799e318bc55c97754adab721329edcc6d2c10e8af44cb2e2b54ac96d07d5238463628d10c40633ed9fcff421cadee0dc4ba7c3ff1c4f1cec679e1dbbd00f029a6108f60407fa0d74bf842a45375e29506f386c5772585082b2a374d71dd56c46f4ab53a6ee2b3aa93dcb46c0c341cce3038a740026ead5816e9f27ab9059a7cd6bd8cb1c1e19e169f08c392b7ecb0c3c34ee9be6512a3515117d0ca9d83060eeeaefe94e4ed061b4e6eeb23aabcf613fc2fb3d422d9168fa524abdd1aa7320b672b60c35438282ad1631ce45a203d5ca692449e62aed108ecd6d73df660c47115768130175543853bc9c83f50986252b9c110971269c7fd879e27ae161ab3f14dfd2949acba207eb1d157a48805a366afd2c8a2e2450aab0156af712ff5b7d7eef4fe2d21e7bfc77cf7c72a683a724667fb7b79bd97e384736c813257dadda8ddc7e42d3fb6e7a2d82a05e3e07ce5522dfa5249be89d376b3fe536ad9bf452af8b496e33424bd7e03fdf990519f3dee5eb3702f0cd05da6d6fd836cd4e701bbc982d62da8e7981499ba21de3d7642edfc352e44e42b8fd334e154a6863005eacb6a52c2a59451732e7120021c4cc2e5be7228404c27d74f560f29cac88a1c1e6c70ab243fb65ff113a857e28313c5ef684a96dc3c6220eedf9e6b22278fd4d11f7d1732b49fd5b3a098d2e0b74884a1c6d0ac48608173c6209e9898b36388234f9ec00af1a917bf168ec84861cce76749a1d73fc0b21e820501a7dcef83bf8060f3e323412ad6b2ebd51dbe9799ea3c0654cda908c41dca4173de64efc118dea936cc41ed5ea4a5abf7f96c8135be73ef6c85fd1cd74fb6a4ab221c031a1dafb681ef8a2adf9837515f060aaf585e06918809d5297d97029d93fbdba929361d454a5e0637509f82bf68b83c13ee8f4f369975892cf4ab8b62f5e7f90f48ccde72e79e4abffd6db674e6ae1131bb21c8cde4a3d1aa8e1cf62d6e13ddefab832c012866cf6ebb7b8088915466530b3ef05420d1326c0584705b194925f8b4b76af7d91b52267ba724f90394fe8f50053b67312df12339b0442c020a81caac76d5a0fe32e4e2494488932fef1207c130a199aebbc9ee450910db5dc198dced4e752fd2705be9b611ee87819c636e5e679da73622930a58f780cef726c19c1e83a073ed2f6209fbdd71039a227139b875fbdf447a0d6134613f2c5b825b95943660b3085970a930369b3ffa4e9d1e64085c527bbbaff0ea3346a12054706df94e99d221d3e53ae22c65281c0bf0a24a44f591d863cfaf3a53b8a99277de7f51cea5f28833d85943c02fdf1ce4a017051499337485706965447602c6f708412998cee74f88632b47552fb698fa85db75ec8879a4e7c475d349ea60e8b15e420bf64a89e2de6afe052afda10bc404b80475cf62afe4e59cc99f8070347364e65c4379c09bf46b6d81ca2ddfec88f463595d051b5b44fafd02fb5040a9b2f88ee4dda90cfb8c0e32433478eeb8eb810a038350c250e138f08c31c7761bb09f3ccb66e13b41905e09f1ddbc23a8fc7c88a7de38c0f7a70dc9ce09a74b586bd3133007292bfa79198b604fff69d337debd7068dcc50d2e7c401eff79632a8cc55cc1a5479037c2e231e2c46b98cb460680e134d5781848dcf6a45d65949b93be57e00fb1ae87ea344532aa534e1e7ff3a4669796ff5fa694ace98508e8a5e42b1b32e30b319eb5e73b9653b9aab89dfc32918b27119f19a0f4463881083344ba82f3a76fcc380f0437866fbdbece727d4e3fa45820560828002f49cd728bf3b2c68945d21d4a6a3ff2b8820529e2d1fa4d4737a5a4fb5f95cc257554495918772217d5b9409a34f8d8904efee2eb354cf6c4393c842d4d1d8eec28a1f84487417b0e1cf8cfa5c94ee164685288b40db148a60404f8ada7dfb28158bfa9c3c1119576a85947917b396a76a23f1744d216815a770040a20ee5a228dc14a815c5153efcea5368eb634bee652b90fedf6e56f6e47b3d6f0a7353507bfb074a0ea70a63dd50a369f1d395c21b9ce0c0ab37deb8c294b7d385d450ca16e3d9254f8b09793b7c94bc797714bc085453c9fbdcaf3ef46345628d80f70da13b7f2fc15810d140a65410c870250c95bf7a6ddeff78a385594e1b1b0e86ea9f2a60230f62a607768704e5a7bcc7f688a3589b999d221da3cd8a90ac5e821965457ec0b426b6d34230ece02b3085cd3f29bf73f4e1bca786e8fa079a1d92ebfa00f558922d68d1d957011f4b307b67a29ef7abc00e73695ad2249ad71fec881d0971b83111a524e3e54f363e2948818cf08911b42535fe9837ec892af13beeeb85b3a6a1a436bb8a39d760ade2db9a6d2977f32aa31fc0092063a7e5cec54eed0ac2beb94f5b3c5e67aa8701084975f1812c4d8793670cc809a5bcf5a639ca5f9290eecf9ad6d518ec18b4079b50ba25016d435f004f0e98f6dad1bb27ecf84edae2f7ef58a5006e57c00d4df4be3bbfea352ff74c6277a7e0874f0f769040fa8cf59a194fe2259be75bcfa37f82a9dfad48abedf834b44359d58edf360b5a2d44c972e2df62d10005160e6a17ec90c78109f65c736524686360dc5d507310725cbe17d45725509654467f893487c00fadfac978285d769b8e966e4157338d76868bce9943390819d02c5b2008121d1b811881f19ccd586707805e23b2dcfbe242f96344712773d78650d0c46b1cce053009127989acd5962da270d967c7e50ab72d1aee491a440fc0c6d922171314c93718ed50f00991e37631f8aa58ba34933135ed63d64d8ba85657c0733a5204e67b9eeee7fbea36081c889820e2d8dc836a697129be9c352e9692d8662e1c5701ee1993642e7ca900eed416a138ffb5ec41b0a564fc8f4ca9c3e9db568f6026387cae609e71e4f229b55944de83e7a67fadd9f201180f9336363850c38e75bb0ba51c9847f4eb41d6869567a194e475ea265b334b6bd30a75de465b2bdee6725a2b2ccd24b0ce43b2055ce232103356def4a43e3799c4948dc90554fadd0e9b145bb7b793ce3eeae4958cd9108e9c3ebc0debf28a44f6237c45dc26ac231ceac8a28d32863e1bb4b4a71fe75c15d09829d20dadfe3c90c951b38c886817679aac2f356796f232db93adf4e83101d6785a5a4bfa82f3c22bc5a8c3cc4b4679385999bb45978144bb3262999e72c2b709f13644fba3e8174e9ab3046319df6d487cb01771e83cf352615d9ea8453dd7439d7c008be456210591f54f650ff4ebe6ea0171566b31a2875feaabc35460b84468e235cccc1ff2f84f01eb436737ed5a999ff95e3cc10bf84bb24fe2561f026c93f8872bc6cb03578c9fc6b14eaad02efb8b7a447a68325fd9348bdb08b0b29a8cbc78824ec70c655bd91d50a3229b36cdc2ab871ce7fc7f734124f3a6ce04266fcd738f359bcdccdc5d49abc6a4df430424a19747a413b09674b36eb7c867e926364c59e06ea8db48c65dea0fad0cd2faf24434d28651d943c77e5566685ffc9ab6af69784a8c0b8ba70824203b0ec7f455912ca6cf9fb8bbde37cc601e2890c2362b008791f7e32193274e42581b4fcf8ddb2549d4c3879dc040521a5e8ad905839d31f05d3de2f8109aaa80f9ebaab52f1baae3ac729e5a61eb01410d8133ec938520c4dc1dc3cf686db65afa7e4e46af5818af9a0e959233b8aae73e2041217dd6f284ddff56b0cace0b44b5d7b755cfb89574242cc04bde096b85899c3e391c86da0ec6581f017c1f6fa3f676ab54159708d569b0fd6d44c69f5415a469c51c3a0ee159ac80539a3c98fef8c49cd2d7717d2ce28b4b7ac6fd0f4c9dd1809306b4b75b40518b207bb34af8df9240a1dc4a06d2226e4150979b0fcc397b076da76d3f69ac2b340ed6f6395bcb3a66023ea987e3879c5711e64b9cfe5457ecdd75985ee8744e77b7105e251087b41bd4580ec35d49c19a2b89e7a464655accd7686114aaee439aaa6a696c073d54c34a8779e05071352fa27b7749a488e7edcf4fb6c8ff64c44a057be1133fe76679e1f54e98185e18dee60a58ae0a58b9756ab860bdef2deaad51605cfa5fadc907f434e322420bcb15a310d066b0fbf48fd37a6289ce2e4f4a968ad01dc4ea862d141c8fe68c54471ea729bbe41394d8794433b630350608f34f7656a60f1b41d3c2ab5b39246adfc216d2a6cc8ea0204a00b2ddba37ba9df5d886a02d837a02d8c273b35086e6b2b2bc3cfc07cdc95d7e4cc3f727c86ac540a49a063862ccf312fe13d4e321c07cffbdc28ecbbe372edec591826b8662074c9541204002988e381e4a008220b838c27ad923bf2d22ae7355fd9b9f8295e352559f2caf98bab3701b68dea9d9b7bd530748cde9720aa85121683961a9faa323f087ffc1be20da4b3c2f351caac348a7ccb6b1a0f6fe2145e32a45ae99841d460393f281508c1c583832fb5125c8b6128507bf9ff8e47f4dec914c06cb52980d0598683058551c051fa86b41990dd4f8494808aefa1e75abcfe9bfc590c571258bd5c9c0c20e5d54f31f51560cb043c3a88b2ed7d4660959b13d61eb392281687272b46f853c0d5dffde20302f090b2f85dad7f5a01c1d59aeaac2d52c6f119f8954cf4be423a2675d5c7f1f40615760e656b191fce4eb4449c276179563d0674058830ab4061c36767e62fcd8183512b69dcb9a2f6a696fecf3b39905033f7fde4e6d5c989d0469c3059d8020f2a231b6f350b9d19dbe1e4cca1b6c9f92d6f0d78070c76d247e056b044219b8ecfdfce7cba00414fe1fc10533de4cb49beb504966859d3c61231b6ad58ddd7787b4ebb825f0c63130fb506579a18a4fd498b0b0099df0a4cb29fc79795614ec09ba5f2532fee4fd518fde9451dbf63b35100ce1b5eb4536351bf2af66c3d11f3ab34e20797d5435bd2e9a271551cbd309173bf8f38db7efe04522c99e6b799f1351ccf8ae3e930d6523eaf09f0702564ca70a047b1e76007fe9f094be92d4e1fdcd36bca09426d7e7ecfa5be17ada9f102e797cfc823cd3aaba7b76c7b12cb95a9eef6189b2830daeba0730d2194160cb64e16c115ef48aacb1f0532dde160df4b2aea78e47dc4dc74eaa5aa0e422b89f01c0d6d57b7a2126a251bc649854389e6e8da52cd09b9626c92444c39dfb7a62a36421ba2136efa8c3bd0614887c6b16814ed873f2e37553e25001dc0ffb78ee9ef74b2e332cbfd55582f6cd16b381e6bc93a2058ebc4040232c9fe82a15d41f527e25d76c5c31a1ab43447a9b8481eeca622194e3c46559229a38a47545521ca26422866e3abee0d45ab25387cdc6eec3a88af5084c06d259a8939ca3cec320bd5a00503ccf3e6245f0e5db9e3984719548fe1d5068df99a509ce4aecd8c21405aa0aa5a3d7a27bb70d01dff9887199a408509e9076ebda8c40d64374a3018faa4d7ece6e00f4d55c3ea942d762e9f17240e2daf18268a5138080c9aaff1ae51201c4bb2664ae4cb5f45489b65dd8c27b1e9d21d715ddd34b767999e83b56cfb37b265e7fb9fc3c0f1b621493aa5b12d3a7efa615f75fe67c8f387a9e0d5f48225bd4f5c7d3d7e1453ac5713a61350efa9c0849f72296bbe93c4916cbdcde47b3d39d920fdac672ef68e8777ab1d028229ab7df0fab8b68727441c3a2f4356d8a68be94c59a5f6f0abf377e717daaac087e4e4ea48a360c2250191736218cea9009a0639f25ada1da5477d46bec42da749b3a19024b790ce55961ed66b00dac2c8ea7691349184a144a300b02a0ba3c7d84e07d4a072679fb96da1ccc3bf640441affeea8b21281bea82ce62c896c61121a72762a1b3604ef6807e032e082236f3bd91aeef99572d0777daa3cc8a0e02a9f8cf9d6f2024374bc495fbf624d32bf692cc90ee087888791cec18b87b07ec4d69fb07a91d2fbbfc1d43348f74a4877ed31b8606a0ac54940fb3ac48c93250434f94a56bf55b5b81b97be998f232ce04055e9a455e5876fb4dd809cb35d0aa71414401c6931246287905e3e59232c86bd228def987c8caabc540d7f8a3a945810c24798e34504f195138cbd64cd73103fbde237d0d726ddc7cf281309012226f986253a20b306bc7db5197b1290b6e62a1704286d3dd02253dfb7a63ee89e51380bcd77420a3aec693cbd4da3267d2241496710aa7e588a189b09141f60beec70f9a66fe20d2faea18052b2437f34538720bf420bbc0b159d5a5fdeeadfd4f78f1e229334429107be6711fb47729577549c95e0d190c22273bb5d53835da638bf56da39e68dc272320b8fb595aa5cd3d3d0612d29b897c22c78a04ea3195a98ae093c21287d32f6bcbd2d8c646cb4cc25039d5326be07c1b222f6251a9fa4a26ff1ca34393f297190009a25cdab1acbeb7433eefe29d314eb899421f0ae569340d2ac3fc1186912267ef52f75fb6bf894856897c82140e35c613da8daa4f45037c259c7185b044135817a413b0bc7c613646fb9c7325bc8c7f0eb1eef17972f26c987cac8f5d5f72a8b84e27524b6d31689874829796576d4f5015c740cf63e834215d6c53208baaee097e9c0282594e527d6a315a255dafca9cba44a14d66b31a13fccf3e31e377abcbb053d5a7c84b8371e6a802c1ee1bb8c6a0c612f8ed861291ea12b484269d94cef743546ebcaaa61f6f1df1b51625bafc9ccf6eb8c2778e969b110bc28c729828edf83fb5e58d11a32144befb28ee94fc471680dbfd3970bbdc051dfe2e2d8a82b691b2be7b01146c9d1f5fbcc7bfc57a952c4f544f762af135e906fa72f85590ccd9123ffdceb2f386bf34bcc2be51e63bf03fe9e41b225cef2e30b830caab1282cd15d07c5539ee819268af945272e25d7f58907f122b080d0ba7d82c15ccbec079462c4fe1ed6ae6f1748688625416f5dfad897493e34af48519e28c3de737c34525530f7f2f0f66624aa735a768fc4ff2b0821816238285b946634cdb0668b9463439b35cede73f878a41e75641ea59a4ccce9d6a52a1c217092c5bca275d5395cc571030f452737367ecd4048d831e6e52745a866cf77c4355c6fb4b919cb92b95e8cd5c9f5c09908cc6fe7ee851cc1f7a1f54060be234104cf6810b3a28f47c0a34ed278aac7cb44084b096720a372fe065466f3d2e2943712d52b351af5ca5bfb8923ab5613e876d2289c0ee8422a5f9e2c003f95ed49f1c35f8859607ccde319bb48a44aefdee05ba08c62b0160560be9ac6ceadf89269ab1ee903a3b4293af7c2072b6545da20ebccfb9d919b5eeaf33f8a7c126794db34ad1316ec9cdddcf0063b72677aa2ff50e6b88c8033734066d46af8e452e5cb5de7593538ea60e95d09487915047c4f4f69700cc5e7a4599537a655694a9fb15b36457d3cc693f2bf176d16de2f3f0d588c4832232c856f1f3873fa42d45fbcc1529203bee66639224a59cb18a31eb9dbba0d8ce9b8198f4a5b80b1dc44e0bb1b1335b4e592a7c69d2e45857800997459205ee3f9b4ba14436d03dedce8c9c28ddfc1a5c41c0a356d472cb67c9f45bd5bb3efdaafa84a07efed5be78fe3a950aa902fb1cc9ce80632471978c92cf1f1ee9be547209e656936847a07199a8d8d98f38d6bd18b13da5d7200f65c8dc5c337fbe6ad70a3aac2cd86c2f894e4fa8f7b906ae5458ebe15680eb386725be235ac9834b7fd","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
