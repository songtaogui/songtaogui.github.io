<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7ee033bcf12a064cc6f12ed324af47764f66221720faf98043bd1ebd0c758b27f167192ad5abe4d1c6b73db05ca0c15c32bd02705a9bf4183c4005256f1dfb1f02f1a1e29c48c8a59be080519b19b59dd6144b96bc3da443e8621b404fbe5ed81f6422f28dab86fbfea4cd4007b4aa0eb29764247a852393dc0be0570389e9a32c2a5dff3f8a2a55f764952f607c6acf9669f79667a2496d6c85d298998d480db87d3f6ff0bbb9960907c1e6a0dd3c53dcbc56de6fcbbcd441487b63f34954f32df55819505c20f5648bde5c6e798c32ae544ffaffee9ed2b73e242effca194c422a6c0ecb9be3818cd9a2f91762fd1b55acdd18e7f99cd86717d165db65927e59622e861e2415d3553f0b4c24a53408f990b8ec246118b7c557f9d070963864762ed1d60dada0bddde573d93844499d53d007da00a793e54f5d5fea42c6c107131d41342f66ef64cec2c0f105f120c30234b444a41360b00c06cc1c14892c9d37c3f1ea66a9be7435fdf87b8199e2cf7ff22ab770cd348b5673b069d7c2d7c8a10266aa9568b2bf69201718a0ced99249ee7a79842f609480970d7cfaa8fb11c74a97fc554ddcea8a8f1ab63932f53ac76a90d025df00269b88a9cf15465aca756b9ed3a45410511461834cd19a204309862afdf46c9f0dd1f09a56a26575993aa0b6ff8b7067ada6b290e0d4fff8688d739b6dbd8f58ccb921317aff887e0a11c8d8f0c317f6f03cf82b8b43ea5ba309c36b581682d59f7cd618d96cb2b106a3913a8ecb4570972d59eab4032e2140290db104ec73813a0009d5e6648485ceea712fbc729bc98d86dd9033e5d825576d3704d9e9aa9b108fcebb559baa5cd9c75a1aaae711341bbac63b9a3fd7808b9c07ba2587c14a2a6b92a178f3c2f5addd85d8421722d50d32459f34a0d4454d2cbfac4799c89bf8abc1dfa2b20016c01fcf481e314d270f7e25f057cca3aa6608b87ea9c62c6d9b39d6e49e510c1e22b8a1a74a4a0d5bfca6388fa46186ed61f1b9f28e36fcdfa01c092d86c0a9319ccf459d4be434bb2853076bfb70357d4989830d9de0d385ba38957936ef45d54fb305279bbe1e7680fdd5090ed8bb85cfb54dbee541d3a87f5ef8bf75d1041793cd8f15190163d317bf31b4ecbadd9d957fa9e69118a641583dff373122d154bfc16e06114371b0755a3557a6ea85ca7b1eac5991b9b3b6ed8f20ef65978adca8e52833e062f31d77fe654120eab32735fcfde0eb3d2a01fd118d30c9a3a82b59c4ce0eb17aad4e69caf5f960c1dee5db98422d58add1ef7b467e1079a5f3e06d1e03d28c610a7307f78ab6c7e64b02fb5c8c4449fd082e4725092b14e270d708ed8a565eb7678fa95015b53d9bcab6bbe129c125f05407b4584fd892a50c7e8112e1757a457a8b0885597864fae66f266ada88dbae92cfaf9c9ea5e75cb237a1fbb8777e0f9fc4fe9decda112d8282dfd77db35859741e5429db78f76c917b69d4c7b49a89c1f48f3159c0edbe459b55d80ac0f92040a5db4f227213a1b11ec5399b2d0add55770a8875ed47872bf85d0b7fce0277156b5ab1cc9555fbac29ee97475a78ba0c901f43da2da5a587aa8e11d33a561203b10e22c7751422b868144da394e573c7f357dbe1a8599cfd1e03441505cf9986c97a5f42fd160108e20bbedf29d828781724b6998881073db1eb20e57485a5b9b05454c02899a028c44c75170461e69f18592a9c950759ea22da54ef365b13b4d751ca7e8bec58621733149fcc4d76f466d683f3cb0c49bae4517cc4082611aea4e26dd367dfa3b5fbf316fbbc0075c111f24b5de402b7ff0d0eb40747093d71e3dfa84b1351e8ff84bf82f1b9151361e95d69e360c5bb3f84c64ef8ccee6d96c3846c5bc4711cd727d242cfca077dc1c7b9d69a2a758a91ab51009ef475a5602fa0ac7ffce050e19cbf8488a6072ddedf331c787301275abd7fffa213a3be737fb475b98dd3b3b4cbdedf59cd2bfd58b4b70b291faff8775b98786bb224ca42697a99af633b4398f1990dac38792c9d4dc6239ea4f2c01e342afdb24e66374a8dc4d84aca4cf6f01bb3cea0c697a06323f1e958a375c6ffcef1142dfdb94a73cfcd132c94193b367e2f26361981489f055d070be12ff27cf210af3fb03404a57a743f7f7a126b7b551ddc33d4c491887e86ee1a2e77175a0fc6a77e96a3174ef25394d108c60433d652c14d668693ca3c33122be1e6f31adbaf9a7c145298fa043dca0abae018069099022c68791d2dba61eddbe22678041a2726db44fe7a401d09a972fe83784ba3c6d9baf036e14010083554c8a1ef5cd0e56ab216956f1f817b9ea5add2491b41565c54c7b4da10289bb420081017260fa04018f3f0acce1290ee64b79e40da5c73061092b6700e3381c43bb66f93ec73e691c3a124bb6700cd99f2f3a5db7f02df54bc5b235d6dc3f2811f3e43a229336343537e8128042a040f808d1e32d301f1dbc2a69e558ec02df752f99d6ac27cbd9fc436a3ff23f81c790227b27f3a43f5ca437fbfd56d118ec091aba723b536ac2abd0c3deee1cf8cf15b316580b72ddd0a96a3893043bdfa329d06e2813d7b0a5b20f9299b8f9f590514a3fbaf87c374bbe25ebc984fe0e69d4df08c76baf85e7893381732d909f98fb6cd61b29468600addfe7d3d8b6e110797e928977bc08b2df920383d814d2d5ee305adb9cfeeca3e3f89435bf063907071b6159f97bfec7c86929976ed88a6b34861080440c5672093bc7a8bf0d133e5cd168d88485bfa5e9209c1d420e1cd8f2d8daddfe894ff3bbc125de47d04da92e6b4a2ab480aada6a7780994395d1df691f8fa2ab7be5f5d401e399b58bcdef55f75f354cfa6bf406778f8bcafd6c4ac46620b95c5bce88ee134a64971646a6ae9c202b8b7b65372814927ccf8d07fcfd954c978715a6261fd2a578c0a98c4483e6aa7deb6a5f3e710281955e2215a4a1b289b787cb34c93ac5d13106c4d93185390a0aa0050a175485c277cbf706380640888d8e0fc90731ac850c8794eafbb7fa53a1d997137c94145490c812cd2da3afd929f5aa10aeeca62b84a013fc214e674b23025c22aa883d9212667632479dc1b1bd62d6c83653fd1d0726d37d05bc8950c1686eda84e3546fe358bc465a3f3b5bad1048941e5c0c2362580d9374e7490036f03af2366f5d2aa10c7b7b3204c28b1247cd05df1acc17384417ea15285cc343333789448dfe578eb7253eae01ad66b5dce143f21b91a27c6c186a4a27dfe36d2224d51a58ccf3f6f0e8d498da41b7c314bc036d23a3f449abad4ba9ade5ee2855cd7e7186ee9dfec62b67116db7352e3e77ec0a5d78e25dbba90ac9ab198f12e1a1a54f4f9a8f3031a54a5aba0f785d8cf445679c9f46d7eaabe39ac7d62bc92cdfefa8c47869a3801bf1c1e1c5a10d11b1fc668b467af19357487db2527c4e9aab003080743158810043ad77551194811dbcf28957f2889d72b3f73266fa4e7f6a5cdc8b5f5a642a6cbf9b38e21f9f95d4c7d2ace97eb324bfe24a4574020eee71a4d3ffada6fbf33a4a2868e150901656e870c3e0e9417d5c970a062cf19c0be911332733bd56d268b2122abe4bfa953a59097d16dd6e80e5bb3cd241f5469d8b6023a82baa105d8e866bae8cea32b44e47b8edbc5ea5fce9d23bcb774b902cd74fc5028d2b5d226220800449f6cb2a1f409862ddb3b626c2278b638b97e4dd8f62baab427e6c8bc3413a0b9aeab4e80b810ddf82c66f1ac8123cbf312bc35f2b2c02aa253f6ef9b240aeb84edd950767d6aab59a38c0a851d3fdecae83f617a1a3526ee3a7a977e86d561926a14db411c8b3454305a8fe5ea97fddb97c9614e5dd8e5b2ba65b3a508a5bbe11fb949a286d400588b46b7d740f481c6756c50239523a8feb465397722b5997caaa7abfb06092faf7bcd5b74c33ac3c77124d64d23bcfee382ac7275b33fccb4fcb7c35d1fe126efa418a4472582f5f595511cc67b383234e32a203f8bf0ac4d9919e0837b2311bbeebb27d217b266617aab5fdbf5d99a65a11b5e481cf487252ff3ce811d8a067294051e16b4b099db22cd4d62a672dc0247b9695bb50c539658816d69b6a7e1c01201ee32dbc34c04112ebb94b43156c698e54dff0dfcf68608fc0fa03d626914e1b3e605bee6494ea6988dab715bc86817553e018506ae59bd5fd7d0b575cc7bf0e788a339bbf7eaed82768badbed7aa2d6d7dd5f69719af34429370a319ece53828b96de6d7d7dcb4a896754186d0f7aa35e0db5e918633d83040f2a46a7435e2ea5b68c7b5d9ffccae8262026341b2427903c087be48d12465df21b7b6e78d0e50efe5e7e85a0c716cb1bb5c7cb7356a4f86e286ca1bbd5702e5bf58d325b0aada1b39c03f9e361cb67402c79dbe0dc72ed9f369c331aec3103103031bb0a059c16b39ce62cb02f34ed5596518926ca894ebb7a28b66e33376aba94a1fff56447bfb2781322fe59695b6018a8cfd4559438b2190ca596348b199b9ed7b3910399e40462bb1d1293ab93ef0bbf74e739247a0796ac476c8bfa872cdfca59e66605c5fa4f6d93967c4b87466d61171f21621fd4e564e8dd6ca34e4ec776cba7b10209d6b0fc89393a825f1bea226b721aeebf110d53cf0571588c4dc94f07f1b30cb8833541e635936e51582564605367d4ce75747886d21a9e2c9f1752d3b88e9e9c260ecf3c4e1fd7207da3d27674a08d459c16ca26e979e8a30ea3a4bae2ae8b85d34c94783b4c2edee5bfb300700503ebd2ccdbd6072b43eac945ee38e2d1f166d9eb804f8d151086b4fefe51a0cf7df27f76f119477319ffa41d525f5703feeb03d9856dea6c2a8cd1248cb5fe4ff93768ee2bcb8152c0d4293a9fb713b3d4ee6430f5d9c8513f6c0449216fd2d844d886a89495af445486eac4a8cff9c11cbb5842144299f53cd096876ca0ff3257493c9a64befa25ccae34f98c3631b8b60d33a2acfc72f392173c28bbd6a2a8893bd266f7d2a90040d6777aed7f4ae0eef2de3a2c5e6232fffa2fed95ed372002fd5cc7613949fd55564a90f0bff0e0cc96823d72a5ef4d539874f0571cc5fb733c8d872bbdb726b20f5ad58383abd5a3d4017c101c60fbd30a421dc038fc4c854cef5615bbed3e2f8efff38d2d0a69f1af3de197827e5e00afa88a855b6cc99bb48f04cea30c18476bf81b72ab549cccb76945e31ae32e68634770be2ce4b118d55413a2de8b99b41bcf735d3ce4bd0dbd31089ae68500f34374fc96f06aadda45b17bacf06d50a5ec737315f5919de6fafba206dc1fb6cbffd9a0da186bb10e3bf5a95da6e39fbce35865f066f0628e029b162fbd8431b97adaeb4c75d3f6fdf3da3d9157180a941a4cbad1e48107252231744533df78acfcfb0835a33fc301dc8ef9ac5a93877d52d446c4da6bf703c1635f3a18ed08a55790ccb759e643c7ed2bfef7dde43fc5d4935c847b54b7d2336f940f1cecfbd22a2b14810111cfe4d84d9e2450c9ef4be4bda81c8ee051b193edeca7bedc4a2163e4967f1b10cb815b52997fe063ec37b805e272df37d45575bcf3b031c9bd878886e194cec640d348078975ab625519287b3881aaf80b4800540cc485e2e6b7832103182ac802801dbe932f40040a800477a60da637bbd9d8bc87a9a9e5f987aa5b91f6206483c7ab856205015b0ee5af20bb47d0e2d512912d843190bd9721225fdc24e84175da7006f7880eda533390419732a63e560ad66addce6df2f62e7d40881e1fb16de904faca64fd2e1a5bd16665954d77e5f1df19c691de606dce3474b60cfd695128289f6d08114d0869bc8c483b43d1714d9f2f7ec991d6b662f62d9d4357bc280ddfe50655da7e855aeaf6555351816c52f56344b54a8c77dab9918d12cb525090c41a42788085fddab5ccd483bffd59ca052ca9c86156a789be46f7c744d76a56dc3a5ac01d2b9c1cfcf437d47e85b5eca5563f58c32f1757af0d896a8996728c09968eaf4c00b61897c2fdde83c70b1bbff0fb04df85ca3963abc3b2c82c5ff4e28c0942bd01022c65436be876e7aa9dd6ee40eaa4c939eb0f7499b69d60bfebea7fe52f43ccafe9addf4b2699698fd7d41a27e352527c8b7b45277b4cc1da212de90a17e75de4a3586ac611759e6b042cee05c511076405cd993f7e0c0a62fd4541b503d0df1fc04fcf1b2e8fdf292d87df943adcda02e922015db021e324e17aaffecf1a93597bf1d5616d27367a93e3fbb98de3ad2820eeaaecb193a9d5c1f24c96decda97d0b87f1f6d4f7deceb89e7164df64657ac5d021354b46891e0c222ab97f7a613392f7f52fa85e15faf95f42d793d9946a08a12eb6f5edbeecbfc8c20d37febdb9f3ab7b7afae49d3a7134509f47e1ee2b48fb9573af4048a81064d9088bfb5d840c698a238920947871265c2b1fd1d74d0e534cf9e984b55597ed7b78f536167bb65d603099e886208cd26d66f7600044fdbef15baca219631c1103927f3a45ac1b51aaa055ac74e78c0e06902f180b06a9be669bc1f0e43b0b2955de514530d8f2f2de90678f482d6c0b76323c40e22c702069d740725a2fc3febc205b7c5f89f375d211d8de94ccd6edf9543dcfc0c95cc24ba318f298545e25b49b22f060522f5ec2e8a17f4b14f78f9a12a3a945e49c014efaf377d8610e058e6c1bacff43b8878695f116ff3834e326043ba2186c4d977e7a7c50ca4a773669b03f53a5c1c6167dc3d2b1de2c41faa9ed69f898bb2fb92ea69d0a5f582991b7f5063073be28b747a343e29285a5b1529473825269a9a088ab9f4967b46df431489516af87900d51241fca52fbf89ffc9c2c7a93d3aedb75489db275302bf6d527f519b888a00579918adf61904c0fba119009d2e5de8cb1c66ead274a00472440ca296311a60e919ee16146094d28bb9ea5bef22e85eabb8217c339ec094ad4fefac736c16f4a7f28b0583ceb580da071f7f6bc5dc96924b655702fdf23dfebc90a8daddc91c9abbf2399119b1cffcb60140eb7783b3630e4bb18a2812df8d125df7b5e036665190c2b0ea6491876b7d486c7db43d625d4fedf8a692b9500ebbaa93a4ca3db72154759cebb91e3e9599b88f47853f64beee781bb7a15974a314413521df0349a36de6e2b27109c9aadae03cc9f2b78684b23bd2a5d49a3ae450bae4be6102a09c6205714d54768c9cca89b8d1b0c483a2d62d850eaa9e09b27ff547a735e310ea08fbaa2987220f23247ef6474ce5d75c9e4d24069aa43937fb4821090215f89e09122242d5188e4066d1fc1bc208d2cf727f19718529b5e7f35b110b47fc34b4fd199b8767a67b1621968afe75c47abfa6a69277481bd5fc3a1ec86f000683f15f43c5824a002f587758f1a1f4f85182df493ea16db7cb48c0be6f86262631122ef753988fec663e178c8f92fb37cea97aa3e308096e6c77fe1deac4e47889e2b76bdcf28fe88dc2e03f5939193f6a45ec11ea3eb7988adfe9518051eba06deebcbfaff9efc6a0eb15ca342ddbce8b5c64bb5021eb9c200cea4c523d1c3ff04d5e0312911aa3304dc1262d32c6f33f2c9078cf8c352fe004d3af56e810a0e30d57ad11c92055ed16abceac8ebe09fe3e1d612388cce8bc817e57f33ed28f401cddd04c90353c4ca4f21f50dcef9f0b78bf14f0b43f4cd08889eb6b1fbd8ba2e389c649058d0200524fecb375ccb57e61f0fbb821fc9ac03eea61f58c86fdc9996c7e678a3855aa04e844181a35f4b74f5d713585446a89278e54193bdc2b8fc8653d2fba1d64737fc3a42d40dda77d48bab982e0f7ffa590b6121e7e0e34bd18d6764bf00c31b813a97fb057108ccc254f08647a2d2dc999181b1e917159cd6e791bc0f989b72d246ef1ad1631d58df345fc8f8d65a4af021cd9edc4cc4ac28c1d95755d97794b0a91d7d27d0ef7fdbd87936b0c45770c189f448e8aa1d02f4931d6201c0c13e8deb60d13797742e7627c2d9065da514309a5c8840eff4ff83c04c17e1fe3f735bab593c9c33cdf4719560bc6849eb51353544879e5c8965741f4a39caa5d90c9d1f848c82031b436f09c1f084e7332f63ed09162a3ddf926d9801bbc642852ef144eccb0863345f5fac8b8b015da024e22db9cdfd0cba7ee6fb49479f3fccbe4e5019fc230700e2a907adfd20786e7f3c143c454291a0a1f86c20846541f234e67a543b5890ac30996d37b56a9f36eb9cca9a0bc0695298ebeea6feb26e9a7bb4a604db7af7e76887ff7a8461f35f9250279cc8f1147f162c71a902dd7f484f84b817a1e3cdd8e8897eee07d9caa53fbeb4e5ff20f94e898cb20baec8b302fb1f965fdfdb1eb4df6dd7f68094c67258fa058dba22c5e25f0807afd8d536119fbd7d0720a1795342709bce95e18e7e5c12de4630d045248729a37df1bc2ba0652fad90ed900a69ac02bbf11013aa076c95914ad7f10808e7aba4e0b0c10553ae600bd8818726771485006beedaa3217db1125ae68b6fd2adb09845aa569a7c7428691455ba4ea4facc09b5deed18581255bdafab28d90a2f3ddf03dffd0be2c1fa4306cdbd4c299337240fb405738dad6d6009cf1fe4eb13b80fc7982a2f3a1c6fc53aace0021fea8a28fb90b0cb243cc9a4f208e4ba84e65dd1e992c5f810b0d8183d24a1ec4b4e7e76b8e3968e0fb548454c77b0d98658452dd906c99b17a3f5cdef9d421f210cf8c43c5e0283dfa840b1105dfd9c76cd24c0ac2c0928e2509cf5c36cdc1da5fdd29c7d076da19183ce89b161d5fa684f3845822d6796cc1e4fa3f4b3aa2ac1ef5122f5cce020bb1e4567b3be197f52df46d60c9dbafeae3c54b73ce33d42cd660c26c90051b3bfd07a8c913b56ccb558b17bab9cf8b74f5bbd62d8cc7e6f76a95b45f746e4be993be2717986e749d91af27f23de722248bfd50e9da06ee125e42e0538b7b9d948d4466a5e3ef803198b83b25fb709449727dd534e53499323b4eb3bba606698dccd48a9a22afc91a9ef59a60fd46d80b5883e44358df8660505a88bcd26427c0c3517043a7133d745006986200c5f23c0d4f32d186678092e05c1a0f1d3a4401ce1a8b561b58ae4a066485a030cf9845249ce7c372a157e3245b104dba3a4dba1057b5fda787ace02dad572118551649999505218f77d1f385fe5ca8d28016202a49ff55750da32664b0812aa4df071f9b01b566b992c4ddd73773b881e28264187aa798cce4819fa34c7d7ce95319fbf9b69ab093b8f61e082a75b5678fa7110a5fbfaf0c9c3530afbeacebd20b9dec5039babdfd4dc3fc2ba94fa1389d099623e0f8dfca29ec710d67007afb94719d2f32eb2ed240bad88c882ba389dfd8940317c126611f3585426c5b1c78350e90a541ee1e930b093ff9c013bf1a084444835b5b2ddadba898ddc464641a812b359a7fa89ee0e69235db1df0b7b0faf48585db08b62af4ec09d2863e3895ef056cd00bc612835d32589492f4f48e34191eacbe111d4b5f5118681856818e3d7bb6dbd8bd3f56bb946f3363773e6d44b49992b37a967b855fda7010cd2a06bc7aeba2f50a801460530d12a62aaf3b4ff5155aa843f0c4122da1105483df42df0baa95ebbf842fab28d63fbeb53fae92c65c7ae7845f9ec6cd897d9c1d9089676531391fe6d6fcfcbe88d92e913d05bf2cf6be30556461e0d643b16ef8e3bd03f6472b4b81849804d93fdb107b8cd8c69124a08b0d70d37ec23b048fe9c98ca76829e7845aa755748942b060a6abaf5df259b91941713012f39dc7b6600f09c317e5c526973f86006fd4cb149e7de6aad754432fa694f5727198a690241846d606525ba2a691ff1dc726b9e57814d68b74867c70f14e3a2d9e62e66c65245d6990fd90800c9e0e7c24d7d0d4ef81a813cc1b021eef0a585fde0bda3c295d1f1ac94f5a2111c4a75e43282496d4de730475bbad76bdbf8f95c089b231252010cc8f2e008e6b3243a9d3a8610e7529e8270e22cf9d0775dfafced316fcd41ff3021d1e7c6565101b75481c455987bfcb2344a244cc7041cde0cdac314ecde39f8e40551ca8269b5490ed43b881ffea3d0cd0ff3ba17986e303c93f835d52eaeb82f31558ae12bda0bd33ae76b5c46408465bae6306cd3f39b0ef83df870df2b779b11c396b7f7d58cb13d957690bfa9094f35b48e93fa46e2658a5b77c97ea6e00719b01523fad1a28df7139778f9be279b4fd9fd501cc8c90525819ef343907ffb1cfc3592bce273d0f5461f197ef86bfdb689f6a4c70632e7bcb28fff18b41802f4b21069ae5dce3ebc32b30bc7aeba79876da3e4073b3aff312b8100a1e7de2464f5281168ce6397410a7a58a63ad2cfa5b41db8246223774df290dc2da399317ccdd37885c922138d56aa52da8da40c37c239917dbf2a35796d7b25978ba97a94a0dd0f8e2e3b0c6a6c59f2ee45c9ba7abd8664490649616ca8fff9c10114dc9beed7f056afbc05734ce60a5710d2337d6aae1fe854b09a4fddad7e63c00d81a159aafd2f741bd4e97c63587deb8e20d4ea70dc1ffc1f644a13d9e85898fba84c504515b1cf115c5339670ff46b61fe9f3d566e1b6fa9daecd52fb9d1884f48d8c947eb34b429419cba1c471f65e6e8f29be59960b6866d356e0661d730db1a49f316f32790268506aab10e0b51e76ef26315084c8b240220830dcda685b651a489179e7f9f1cbf59cf8796f374efe93933792e4b4391987f5e3ccc8b982454d79c84000defb5014a509167df956e7e6f85c522b69aad07a5e60ecad9ddabbb245b76281978a99a770b487af3143478eeda0e2d703c317cdbc31f86365f2e9904af7d620df0fa4d1b3fe369529fbdf723ee993ff7817c1a755cfad57d264a5a50eae837dac658f55888c267274390e4fbcdf923467615aaa2691a53cb316db6402a0e5c4c36697bd45417b843c11e970ad1fb98fe6b21a8dc17bbad52942b87355497f942f4dd4ac7c2c0a34a5109755b6a492b6c6315c75262443af5bd96cd39c1c79be461f19e8c0d154e1a38c69ea9d2e646f64dc87186192e010f233a4749f316527e206cffe966b785a9437d49034c274cb0f3f66a70d62493cf53557b955a819b8f2d252b6b658ca680f3566ca7cda740c774608da0015b52e77b72919aa4277ab7102d3426f22c4fba1ada73e8085c75f7d7a457a5bb7a213e35efd7859187a92a27ff9d35b2eaa9556df4acfe131f7aeeed91289eb1f4150283d93196db34a740b64b0eef0bc53874d49bfaef90426cb5b1a155f06e1e4a67b27ecc7f323a61de1c4d56e56a467d43529b98f4013b233f8389aeaacb612da4d36e22e8be3bf0f33b15c54f7122d0fedcb4e25d95e35bf276b2a285586c0f1d3931f34be063a19edc0e6a383ef8281ee73ced4fb1747f7e4fd35d631952dce328d1ae7e041d8b4d422fff8b9f14788efbdc30782314218cb0e2fd20f3af3623c5aca95257797bfde4e96b8bb8c46a679e8883dc66d39efc5b47a0f855bd1e81a49561992c37be51341e112af50d5f9e659bed413c9d75498df990910ed4368d61e960a9d0cc473f80f26f7b55e3bb9db6cf9f77b56c7e2fa7f15cc8556d5d783b717bece66486b101e0b026cabb7582b042e1a84cfbef0be76e3c30b012c0bdf882b0b00fa24ff889699a3668cfc4690412dbc5bbc89cb8fae10fb5014e137104bda6ffe44cbd05cb7cc03ef4d6f63ddba80ecd9540b73dfedb42e8937d35f107220b5b4e894da017297ab9ecc86e4534e7cb4d3e85c3c708f1df0f8d281e567b65ad70f0382b6651ab87733d7894f406b821e26876af564e02c0c07d428c0f8219614222311ebba025bf80d8025c321fc229b319956d1035a4d74eb5d9d8025382eb399307575891b9c1cca309328029a2fad32f1734bff4362e298f45ce6c788b582566cf5a7f37f109996872eca2656c19625fca426f6ecbe93270f2dbfdbcbc055c00f0b6edb12c95333fb1034004659fb1e2df718cdbbe28118b98daa8ba2bce897b681c3fa269d228679d5f9d5cc699370f43e450c22154589370cd0e8e8e798395de7c1abdc8aeba82f0282470641c4deb38fdbe89b326e5d4ba49a405dd91d7d3488576c45ec732dbe4b67f778f4d32224275b996efb30eda9d1ac3f2f8f0babf4476e147c3d70cc204435c7024bee3ca9827c662174df786f5d2a31f4f9f9239309c861cb6ca34fbe2a3c80c866a2c8cf514aebb431324d4b91e08c5c8ce48d711d905a32855d923923406bcb13c6b7ad15fc53d09465f875ba9d54a2b9b39e2df159daa7e9dac42813d1d34018adcd55abb1f92978b1dafe577d4cd8d870933a18f11b1606fec53d00e72ec5011faa3d2743d244c781d0da59812223c584ee7b3c30f245478b02f82967807cc631dd09ef9e41935fa22c6e007326abcb9dbcf39b144114b2d2bfbdaf3669c8bb8ce7ed02a9c1459a01881586b0328a3f13e99cbb83be3e635e82a6ae4bfb583cc7d2f8b318d598fad931147f49b98af3142479eb85f24ac5770f506674e865accbc9b82af57d258d446be46545aa6d8cc419fb90a6ed074e0f37c639d9707d085371d295a304a0a8c6db52455c928a0228b3f5c4b281e95cdd0fbbf311f94cd6c57556cbc4cdbc14fb50e333151fe2efb392cd5400e4a3a585e4ce127e9566f2fc2e0cc9a391b1c0ba86b89f9e38dbe62529f4cdd13dbfd638644756615fec65e4275e1568d8209d2c26851994b1b52f72c7491049153ac970943fa907bb29ca9a3c427bc5f33a123092fd5dcde555f0a77b496be3276486477f00a163a0843a248f7c2edf3eb94c0d37939e0e41863cfd3cc9b60a12297c35dd330ddcb7d430f1de661d0cde99b7da7171e3a1ad91bdee718063d988d57ee660ef6770c2bdbdeef056c7f3ea72ff58996f4e2a178ad2ea5487656453b0eaae0bd18fa0a4d2fd81e3a7aa7a51f4cdfdf3ed7d61b12eb709a77b2bc8402b1bb5d286441c071c8bacbdc194809312d4eebf106373ffb22cb5bd582ac2225dda168843fb577d336c84a6703de690178f2a731dff6bce20c210d25d4168ad92122704e08b3678d8567ecd08e2f581069c8906bd11dd1be6fad2abcfd8508a0221a9a5eaaf121944a44fd90db7207fe56c3109945d543932e140d9a4ca171409791be091bb625b9c2442084fdab8cc13eea2eb9e6d44af0c4c3666dff1e3af2f1fd923a3ec9af90189df0a5c1fc604a67169cb026ea135394c8e64bdb07a76a2fd7ac28c17a59192cc331a7a656b499bb923809f9cdc7243c95f2c3937b23678c94ed560d713b1add12c15da28dd604ac29ad346738a8461956a5b02d4e1e5ccbf21b9ffd4fc828887c2939801e740c8bc92d600aa539c3f53d9442c624e65fbaf6c93597144184d5054266678ea723bfe106b004c02787e9f5940a07be53df14b04259f31e9aa468940f7f1886e7016eb47a97afea6993dfe1035ba5fa64fb0ac254308049df4aea064eb2b2b233813147af8bde876acafb1368acf94591b4fea62380a46cfaff14448dfcf2c6ab26c4a5b2e7c350068e273dd528f52aa17703ff4e927a58a2326206c5ee683bebb6239bcbc41e370e0a49eab6cbea004875e86306c3416ab4938fa49f3c124f8a4b98c15a7cf0ba624601048ca3fb14e612b1777535a3f96c58295bdac73624c812e6b9e08bb6e35a3143e0fce1817e3aa7b6eb6e87ed9f823a5448ff91bb88556796e460f53a502a6c6fc752213960dbf31c7d996ea137e724bbc1c60d06aa88592f08369753d8916f666870ec3932007ec65b48d8b2f05d879d5e4290730ab681cbd88b9d782ec2d2932624eeb4da984dea81251338bf704192cf92599b25dc2d6dbd775e1f7975369ad932b255ffb5cd0c8578823ef76a2c22649850cac9000196f8441fdae0ab612f5edb49d7efc6bf51060dfcc59a667252e0ca4e07e00165e7dca8bfa8afe259e61bb4c01446711d907554d331f947acfc752df7189997301b719c8cc941b04eddb2729c525156e1b6948ef59be49e3bd1c38e345c4e2e1b8b2b2c80f8cc3d239c909fc93d439a7d7a02ebf6e3f977f71ecabcf3ff7af71caeaea79fd9cebc465f49fe00b667966be06522c62bac307704ce2384e3d08d5dda0f9703916633ee4c92e43172062faaa011ec2ca0db2b23d9fb563c0a5119adc95e06bb347789bc3c0c5917539bcca6233b835b7e9e8fbc8c9cfe8d937bf2812dfc8eb410e2401e2d669fec3aaf568baa8fcd9a0b4b121c93cda13df9e4d2e9d22527cfb7d2c8bed2ef5689c69990cdad1f0824f484117503837cd8ea85119f787082a6bed9b7ac729b5b84eab44a653b997b4044838d01f5764dd85bd48915cb7b21e7025a70458d369a275b65dc5ac48f4cd97a1807a56e4b5f90e2dced673ef0644960e973dcd85e3be392fe54e699ca3b7fc49d905536852c8d01e3f57193e0e32ad7a827b13c596877f7d2f734b778090610ce241177e6fd4feb9d42c41945f7d065e61dde2d1941159ffc14c62e214fd72a13a7171cbbc5c11fabffa8f6ea8b2d129538f22ed2ad11bd0d965894c2522dca692d5ebdd08a63c93444ce0d0465774763fe77ba0f06b5b7b3fcd67bd7d19b5215c2e4886a5d18c289f890651a0d7b85cb4825d47d315afbe4fc97712503fcbd1b8806cd16b5d2560a72ccc6ecf88234c77432493348fa8461c22446cbcb3011f0aefc9652225f77ceba7fb3113bc2c252de223889523450e7002c93ed198d91260651934d0d7805a6d018b6d89f8d858951ced6352b08e98848aa8491a7385c7ff2881b30bf912c0e0de80f43988d9e0c46c571bfad5949a464938281eb271241faec0fbfdc109736c67baf685e904fd8524e265af19a01287d82dc9378c4b639db82b39a20de5fc66ddb86e647fb8c69c976fbe448da78ff1402d9a29494129110bb18505c4e18b7384cd0c8edc4d38b5f5c27254f17ca6e67193b35545fd8a0a6311c65cc6de1a92bf9919184b8b275acea367fbfd4f39705940aab0a2c2c56bcb6f8d19c0437c4be56ceac8da40c412bc22e92a4c4b9c620e0a355277539504c9349017bc3f6af45640b7ae99dadc44ce66c5deab0dd64ea99cc8998d49cde827cd92bc9df57f34ab4c0645a12fe6828a07f4700b7a76d74432a4f2651584af20e33e3acc5c6eadddbddda2af90b37ed7b91696b7663c203b7bd32f77416a6143a796418d0c5ec3751d1bcd3cfcd990176110b7dfd2988bfbf7143cfb18442444eeb06fbffb0d7c60ac7cef81b2868113fa03cd0536daaa4ea1054976f79cbfc0500338858306b903ec393d4d383f033502c3f2acd2a5bdd154f127322e2179c719b63770a470980a4f308cb720b7d07960a463a13e6f59ea5a1a335901eddf1bcc6fb1443e2b61202f0d1dee100eee2f39fcd86076b9e8f5860b90e0de70159f0e6425569ea9ad7efb299e58b41c881412f95b4a6c412859a7ec5d6a9391b237b728a62fb12c207a9071de9ddd71f2e5a79f759b0964347ed1c972ebbc307fd7aaf20a4360fcdd65577210d4ef3616ea9679be38affb81791fb97468b0b2404e9cbfaa1637dc8e35c1e1bc81f6b785a6652c8ba7b70eafc114f00870f7bab0105b7d3298d15b73614ded76e6eca868ddeeddeb0df78c2ca83fbdbf175afc4d07a861cd0985131c5252a834a9aa6b633d584cf20f316bb1809f9a8640f9ffb747f42ed279a784f6392018d967c2a8222a4186488ec7973693793040db80cd0c8e140e346225b8ea4675e8dbab89045667ad93fc011df239250158f5d18cdaf56451fc4662b5720946028c50857189f74d59677aa41d31ff64141245cb78efff39f0322a26588cc5f075d692aa0749d33a4cf2abe13c55aa044d3aacf299d534520c14277443b24f1caaf4d4ca9d0c0e46ca8108668b27644c639f8a6a04b678c90e39d4cd0641da817c629b0597a3952387d94e5bd677e2819ea4787a39bf507262d5edf188e149b5188eac23ba5e4fca40a9134982499953803c35ee152e9fb55e1fa672d3a2c672a2f5f525a9d0196f5a4b1aa0aef09dcaed6fdba9df2a92daa1a730ee7b08b730cae582b981e8978116003bc98991faa6d292b50f69820e22c8d2a038f602733604717054d1ec07ebaea9a4721f3161040fa6717ec4768510c141a0dd9b002cc058b1117b61fa33c77444950f10c49b43fa3f347f028c87032eb90110f95407803ea312cf9081816fc7b06538ff64093e119dca2571c6d32a30987796ea6b68cac9b9456a82bd21f1e26bfa34a46f3c178b87361eb45ff3572790d68e785d6367c581271ecb42c1815ddcfc9a2fe3e7f32d64873c46bdc18ec224675cdc22fea68fe3d9d5b15ef8775a58689b7d424c0e6538909e10d72ead0c12405590f0dd5cc05f69594b6213fc02e942ade03b08cfba152cf26699dabaaeec470b363448433db8fc9ab689b6ac00fbb148150dc788cda2c67d13fa3e7449948ae59a8c33aa9034a29a7ba8683c397102f45f2c55ad9fba0ef557f7a818e548b9953a0a4ca33420662e490cd61beeb29cbff6e28014702b9f56dfa7262418e946152509af622afb8c911a875e0524c0d66ccafd3f50991578334c9d0c3215c46e001a75e7eca5d3a93e644738c0fb8ca987eb3f5f881d1ab10a7ab5a50cb7db8af4b17ca1d70e5e9ec8686a8011e9bf53caefd50c09260cf427550de2e4abb3d36cb2fee1e4167f17f7a2e810ae53450db70c9a69fe9aecd805455905a3f7759b260c4d72de86edccdabbf88d0ccccee1926b266b79f599a29cc052c28642bbdde3602de0fa4fcf3f0ddc451bf07b51484d7d3494cafd4f47c681763f5477e4de621a67cd113c32e9b42842518d19cbc55aff19092e3523a63261e8e476bd41210fdadafbcafef2e4715a19999bdb10f40fb1a12d6ec8e53b053ee4bc07ab8af72bc1af89ae0e8f3a299c44a86a3286a3b4aca647acaa9968941af93605b2e3e2524d8a999d06a8a2670bec2a6db81e007e9a83ddbac4afc27a58694a8e30bf604863fe58457bde34315d0cd5f30b3d02c8f97bb3afef30c52e45ba5a6bf7ff904189758bb6fb41e9a214ac0a0debfbf5fd9b75555e43dc8ca947a2aea3261bb48316ebc5427bc14dae96fc1a406676aa38bc614c21e5a701c4a991e3a2f053f9b4a23d1ab9a62d32eb3319800e1f8807859d6fd02c4f747d8f333a48572eb3645b8ebfaebf8b26d34a27b73217f32239d7608563e1de6f57da2ef77badfa1d9ece69faa961df808d172f1986cef8b5eaa4be2e23db0a620265233945dd9a82c9699cba78132942d7be636350437ed33044cae3bc5f3d929477bd5fd6bdca51edb2a08808f1e4d80a64588394c4bcd3a2770d2d41150d404261595eba2b04d01475397a88401c8c7470f73b2464c12a8b61ed7b2fc86cf77855ef4b56aba628c5927687d62530fdc9a82d54217a03c9779faa7399078bf94d0a205129441feb44b4fbaf94f4772c697e989ffbafaaae35199533cb18cf56f498eed2b6ccc9b090c96ce281fa16a9564d624cce0f68ad20120b8fa3aacc1ef21ae4bb2753f8fee6d3647cf687350668223126dd51e56dca2831b4250be251e820c231545fbe77621af814f3cd56e46798d68bc93a216d9b7372bc21b1b20e3042d82191e41ecb5ee834a77b8e20f716d7cb71bfa46e3f80745f1fef9d34ea566fe4983b101a6d88fbd672192c05c10b624326713ca85694a95dc69e38b69ed921a2c6c28c7a195a04144597952851c43f551fcbf7b89f0c0dc14e36b86c5626b12f5f5faa1ae487cce59e499b9d733df87b079dddc04fce0178ff6b3c026c6512c33f962de242b2494b3caf474663fd3e4d953662f92051db07ef4df9f6e2ef32591a9a74d5af0896444566aa984233eb27f10d7c3f8a358530ef5f9969ec66631edb8f728314c95d8d54c02d98452dcb4b632f6925ed2d5f0015139e4233927c47e97b8269b35941eed34e1e09e1d52a6f3b5f694d831e1537e5865eac283e165cc4a8da48630c1689b0897456dc4164467fefbf085fa4623aa4b9d6f327eac92080836d55a07afd6fd2c1516d386601cc95009e1e27689e3e55f0131f506d2044b80a695966b06ee0027f637dd1bf56fb538503c648d07ef4376a640d54d9911af2410f1d089fc1d02950a5ac125c23bcb422a4c5f6ce39c7c5734f344e98d8d72a6acf12b7c7101adbb1ab4a7136557e130e7af28fe3971f4767e009430363c5bff7de64a954132adccbe7cbf8368e62d230c67b56bc9d086706a405a3ac4eefb5e3829a277e8af948e5d6db69272f74a750e85e2a603366f7518c926dcffaedd1e2e72e7490e5741b29e7c942b94834aebc5d6c25412219bd157248c47d384b148d4027165a3ae5d097ead7bbfa10a446f9530337dfbf1d7d76bcbe2b1c866b557a7dbcc6a01c6b8628c7926ba9ce1d465e6ce0629adfb15d6ae3c1c8e5bca1576f6b3ba1cefbf88b4e6e39117eb3cbc32c08936af7ccdc3bd3c591531aaa8d5f6f49d4c3d8a692421d0ac3e856ebbef8395bd5a98a5c76b44e6cf497110293cdddde9c5030989629019d373da9fa1351f121ec874b02c89eece3640e5bce1a924d4b8cd8d14a59fdaa6511903d1d8a61b78a085b809b58856b0a954ebe243344ead9b74b","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
