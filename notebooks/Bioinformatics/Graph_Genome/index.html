<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8534e0ec65b0dc72b7355cbfb460abb8b0d7865a1cd90736b90aedb483997003ae9e320597d2790b497ce37fd7e88515f0738626d8085677c049cb8449d2cd2125dfbc6cb1716e0b2b7f51a8a9b279c0d9f5b1d0b9f59aacc826658707fffd8dd6b32e0f06248fae56e584e20b7de0c9f99ce94569f189c2a887b15044c2e8b69663ef435734a2c036ca9b0c9dfdd411f79fd702101b328efb41a1671b8fd6b8bf3d30bf674c3ec8b99960885ac951a12d97416cecc88c94c46e872ec34f5c370eb225ea50cb1cb7e67baaf9e7e6935c65ae372e8d2e66533a28c2c8f7277c27d206c298368918504c64d179605c2f4dd398bf4945032ced496f3045033eebe726e6b2739e9edf516c5ed4b3987dc9de79d042a69beaf517e935d8f028920fc1f63afef14f15ef17f0742cadeb7bab1c85a7e2b52b33f5d977e626c0101e8637c185cae6c4574ea241b80daa31ad19ec7325e1e77303f0014c6af1f43e070891875cf426112c73ee74c5e6d5b3887cd402d2d1e1e302da10f70761449390e5e5d1a6962ba07192e062dcdc5fab99eff76227224b5fce61ca626d3d93a83845409dba5a0f76a009fcef372c6e0e01464c0ea43024f0c112ff0e487d9d3119cedfab5d63a583bcc81a7b0a91e2ea093e74c2638077faaec951fd37451c4cfa5513a0b8e08ebcfa6718395c1d4d598af79c12e0a43834c23894c1608f9a6c7a82b300b41a94987365c56e972cd9330e0c3745088366565988b4d97d4c68b6f4296c69930d9f86c231766d8b59e5cd833bfbf21f89fb3606538920fe5f30aab4f25e4ba821932bd1e029d47b6eab487520b284c20c2558e229e6e1ff26a9e4a5afd3aa9b8327ca9e4ac05f4d58a7c144f1f0b098bf4eebfcd45760a6e8d06b4b64e80f40946a6c81c672acabf04d5d00e7483e9bc8b84c71305e355faa58c3fe7710117fb6cc9dd8ef7f7ec08fba767361dc4d25c9c19fa5697c5b75dbab18faa1ee2faa3980e9f98a12df12167af29f63395853de41cc7564cd6c782c5cc68f9a59fca32ae1f3ea79a084f4bd9e030d3a705affd35500659a9835d6199577aa48f6f4156f5e61e3bc1cdff7beb43e6282bdad8a90a87083fd79cb10f5454807c1ced0d7462fb3fa5d4e7a655c0890c1fb47bf70fe768534b8449aa1eb97cdb7c9ca0d9b925a2257b33639da4cdf963090144699cdb704027c55d058e8c8b653879a0254ba49434a79f12e86382107457ddc6d966f9fe0d7260b850eadad28f477cfd41df1fc73127aecabc24c5bdc610800e3997d3d31a574b0ad22841d9e5dbd2eb2b9ae0ce124be044de062352758fb9e5fa692269ae755364e88e79210d5f0c991467ffc26ad0af09efab63647692914b4db109d68c2d7a7586cc6770d53e84da52ecfcb0265cccf11b6eeb1c6d3a539c0d17beb9603fc2bab0691896a82a61aea2e1c38f1d712d282686464719ac64af9d596cd1366d86d9e2113a943627abe44f02bf67fbf407bedf8fdc1af15a1da1792f0dc1bcf00b513657e6a6eb9d00bb5b5dd686b93018ce03127e7d39d7c8168e4ab0fb6b03c98c794a1df214fcdf0bbd45fcde78fd826daa281c5d8e81572de07c510c28022ed456532a0bb1e4705c1ca6726ec88dff7379eb358d9e3ee2f73ca1cd49d9f81e4240b06af85bcc25259761e9031766dfe0562573c56391928467fa6fdaa22e82b38b82915b8b67dc5514b703405c6ec3ba52075c63d9630c81c5706d1508b8bcf59ce01a09ef9887eeb0e28ccedc58a7fcd922e7e16ec84cbecb003ae915952dad38d6cb548d25a857805bcfe2a28bb23ad665ec20776b01833726fc6273c4cfb7ab059a5cc182f766c94ca5469bd29345181b00a7ad855910f796887bc448861c35183d11bd99a6c5100abe0126e071f0f9419d5c52e5feb40ce29dc6006b007b9e6064d2f300186069c5d5b75bc6a8a4ed2217dda52c46a8feef2fd272162b20cfb71590b4bb31362bcf53574530a913aa6c1169156f0feae7b91344a77613298f5061ab3e3c995384324fdf5e0763a5c2bd002941a94379bf42aa25405e0d1aa3ded9ec76316cbb16c9a0a6d1a924fe7999db6e57fc323e2f3d8ae5db2b78c8740d925524cf0ca898f84dd119a2ca352274adef5ec8919b0e94ffc04bae81ac7d49844d30b264aa1faf89b9eba7c5b20b0c1dc7a94745a306bde0cdc9c6cfcb1243ccee1d618f06be29ac352ae2147ceda52d016c37f1b3ce37531ff1faf21124b04085ca37c5f1d3f56178b02c98e4da67edb6e18074978ec816c45efea451e6b1ec128b5b90eba9b749e13fef1bfb0a6a629067a348accb5bc6db0ef5e2309cde9b60c30cc8333ed934667171d2d0bb9123baf24ec76e7dd77293375004f8921677a0949a78705ac4f378fa3a317d0e0b193144fed022082ed675c895792ea8b03c3a7472df3cf1e684c842532bdb43236a63ee267bc19bdbc41c227d0b564c08faca9522685499990892a733437d8e705d78d9f883cb97b48ab642e40ca150fe03e43ca3498ee5a5b7b54244447ec3629a7256b8ea359b3bb2062628a29759df7c3edc4c29e611231b634b5244e07504f0cccf204f789f0e92a8be39dfb604d68ef5e33c2ab994ce85b5193dff67424eeab4fc2d92758dc89136d988d87f5db1f629dd7e0d2860107ca9d441a4a602e374a00933dbfa186b3298d520be81e1a48c518016334ee8e8acf4156dd1eef53ecbe229a463843bf40bb0b493b41722c2c63100629ca770d5086d916b3fba77626cc75158cf949bca06b68e273ab12198930b944a8a1ec73c59d406eb136f11436731f8dffb9f796b85b18f22a14a76bdbd4b93eccbf56d7e8d2a1c5febd1467653d76d581fb42f729a27d259b62d8b1370494f627f99f869ac9a94c7c1ec690c4a6b934269cb3a2ff54aec2db721222a43e5165943fe36a70f9f92a7708d9847b0c2038d23bca333c6ed57f1a5500c7d70219028db47a0d550db525bae7ecf90fb9594011da843154fb565b1fd0961d6cae183ab32969422f8ee59e2267b20d5710d6cedc9ac654de66624c084c12e35ebef1fad07cb8d59af844dab22f4e727f3e39cdbe963d8eacbe4aa92ee94de391648df9ffbe13cd079bf6123b9f6b6df72adf61d6077d8c394bc5895228d5386ab9374e4e04a9b0f20632c7311e373413dafebee97de44230a96e867eb430cd30e2c387f5444f5e81e131faa0b5c8ca9001cb51f521583488cd9abab781d347daa72ac45fbb51e890ad80bd6b484f0c68ad9c545e6b74340d88b7acfb722919902ee417bdf5bac5d853d2ce5fa1a27dd8b3ebbff6814aac25ea41a5acaed1307e4320adfaa30e4e41b31e07e62ade21978fb3b4def3fe461fc1d4a987cbbd87350376c5e23371211d14fe029bc681c5c27d67b1f5baabd5160d53bc6d38e4d9408bd5a1e9ff3cc072115443ee4b460f65723a33fb2b246982dd522f2e7e1ab6467dbcb2ab99874cd74ef123a9a982490c51633439d92f690f7d3e6b1e7c3b4529f7c41f0f748a9dc631e0c722854bacbb607ce7eed2ccd70458a511036556f39ffd46445e74cad038686cb184f3c3c63d7ced6b6d8e0b6f1f15519d8acd8d835a21b304260bc20914417791c1ce00769efcf1555a10ea8a499bd5f084e503927c8695a32f33ab6a0c26d4249805a8c4c0bdc95a93aa539ab076ff4a92bfb0819c0b5d14d6034017f459306ff7dfbbd78824bac872082b877e859e1f0413200550c82277bff43c9eee0e5117f96946c4f608bbf1a57b781f23e871c23df6c79b76ec8e2e89f2531b409384a5570e4581fb630fc714b637dddab100fb4f63d47e2f380e6a729292da021965e127fa91f6660a901827d5be2c2227e82ec28a1b96cdafa4f199f96c02aea98e7412bf3c1f96c86ef34270e5c385a629a4f0e49c94c4d18ffde8cbd8a720143a533d7cbe3a67521fc7c325dd65dd43594eedea068b998496b9e0def4b9e689cccef573c185e416fb80001a54d0585d562ef0d3759d15ca7bd1944011c949e044c2a9e55f4ea17ea6e3eee7aed56740c735d23e5a3b851e724b22cf7a470c59b1f51c21b30cdf7594c17865077583fbfb2eec1fc1467662e9def398020faad1209572d161e5f1ccc7cf5bd27ed5c1105eec4418f6964be86f2edc069c1392a94ea78d3d53240aadd6af59bd7d4709d390b6e6ec85778c9beb46173fb267b31213279906f5b25484fface0a4f55142f80caf40fdf1a1cc8a91df8b9099a8ca34dc68c43899648f328b10bd26462cc45cc724bb611e03d2ef5a3094222aca4dea4dacd99a7f71fdb5919ed27c7c3078d9f6ee348117cbedba8b7933b6238beeda844a69095004bdae1eb12ecece87d5c86fbfc1fe672bc47c30f1b1712e507e4d71ec0bbaceb3b15cf48af056914f47f7247058e8da061b74f2c4d6ea7c6b548d832a517062971d40d20a1089cd115fea4898034abaf4fe753c6a5b5655d2bdaa125b15d4bbf0d997747f1c490b9224306c0cd59b4af443f9835637abc614349cb02272e69fb70a5b764f820897a3f382cda9fdd53925d62d59a526c83314e90b24802343d29e1f9e9a89a6e17d2ae8ebe82e22178e6d06b73f959030d45ba8678a1630888e8fc696ffe7bb890bcc7014cb9628d2e315d909a0cc92ad7c72bb52f295a65cc9455f34f01015bf8a400e687a492dbfbd412883c2b9682382be7aebef1ea58ba1fcda93c222358df1ec219a4afac308d068b965b42e971195ac68a7df93fbfa2fbc064c690676d75edfa5746ab7b593da9e7a0e518f193e2260e0a61bec1d0c10e5d6f5d8a0f98d2a2c61b4a5dc339a93869d5273af19b57b4b32adb35e16e5bfc9094898c910ac7848ede7c84f0a3c4ecf5bfbd3036dedb56377ac35a580cb32d2ccda5f01663a464342d50a7b34067d1db30aa3c74c512e5396bfbf7ec637fc6f3b7229edbc1c6b73864d78392abd22e323ed7cb83f9c85c0f6088e8b15b676c833a494eaf075692c6a07d7c357567457c0753855ddbddb3d8db121e2fa1c9f4afafdaafa72d41f8a30db95be76652a51b7bd5061a2ef4c54c940f0df383c707ee421e3a14acccc67eebcf9855d65440218abdbe124a60e1ccfc227efdd65b5cac8b9d0abfa6f4025063be038ff5babbbdf6a3b2f2e144eeb59c410ded8cd2be5655b30cd3dea35358e5e4f34d8108413e122baad38e916db527a0e136fc17ba0c7b131966ce5a6da1b307f7292a12459698d6b076ade54d9570d2530e8ab9b1403879b6e2a3086b8e4e5ceff8fcace106824f20b06ebfec53178ee540768a53ebf3f0b5165b066d4fa4c318f1d9b3a523c54a02074e52149e9d5414be44e4c1edbe1afb2eac9f0c1a878b1f7532feea61023d393b8316b1ddc57aaa7bf02dc686414c2dfea54868337a37cfb0a69d0609b27a7bf0b426bb7661c95c0a3f85c9b8709280c971120bcf4bd99454c8e88224216e7b7a54d91a040f8f6fbdb8b98f212ef0feb20367f9d93e716134691d098234374fe2d6e20ef08c76323d4c9dc0de23d0e8cc63c68324b0aa22f061a9f3452fa48f3964e4690c89396c718904fbb02d10a33485f335009ef11a1397499026f7e27c9e614df3f33574cfc89d1a515e3eeaa3e83bb9b05de6d53db8d824975bfdeebe6f8001efc311bdec0a7f53a4d4e7ee7ffd8f8519c7af40280dc34a5efca37b057746edc89b02c78adf53f32687fdd40a4acfe0c9bdb1920994c4b7d4b69102622b7e83aa9470e0b1e2e340aad7dc77fa65cdb4b6444700f680b6139628b9109a75a5275dbff9d342373ff5b8c97b0359e998f3dc3d402e28a9e6fad5c4bc6a3cd0d1a384217d4cb797c417d992e1c06d81b0960a745ebb46e18aff924da7a725799d302057e8f3d2f8228a59c56abab65187bf257d13f5632a74cbf93d151d986379726404a5af88859173821ccc0e31e3069aaf850a825dc3d6e27709e4b35e21c09085bad308ef2b542bf0766e2835a3271c4868164dcef6ada4579ba56f516e49311e5df2f474ca6fec21a98e52b51a4800e9a090b2d8ad2e6535477b5f27412079d47e69c321a515119f02095eeec35698bee19d8365f028bd18ad32a5cbe21d5debcea26ca8c52a14bac0aa39e316171532c0b8d9f8004efb579133a752f115d813ef4b4b43726a4f0dd7837c7d565f7c4d8ecce289d2272a0e926053550ca503d83dd5b8e12e2d779347aa705597e7cb027a367597cbea9c9c2ee2e7ab6e29147da9cee6ada4636cc8113940045f89d67d25fae44687013ea372a0ca42082b8ab203b57a2fc019b476f32c57688cbd1e14a5115391bf92b47454af83ea8c2b10fb9916138ab16c09f67dd39986bbe404ab41369567374c362949328d4fc5b69b3354c7585f0e74f8b567dd0e5e70949f4a152f007202b9f946eafe16d8cb098bc75d81a818f62a5389e5d56b4633ff0cb78c8f69a7d06296aa7f8315ecc053c4250a3fe68aa53f63dbd72a2570c64654419b8731a9d6d16de7d1e263013e9ed536359a280eecc07edbc0b9a77f77cb580a2e12be1901b495f537fca438d6ed0bc02d4a370567308c9423ee37a81a49dbb349bb0a384681678dd1425189fc0ed65820fb84413f5917ae8618a1c43dd9bf80cebccad006239d38b910886afd1426e765a7481940592e5fbca3c1289328ae4e3846e816fbd4de0e83674a2c41c1b65d778d859a3abaec84cad6632591692a9804fcd6680132b16da3e7c43576eb223ed77efbc23d522c1ea34d24873bf8e57302a3ffff01c91975795e6afb0d9da42c2532edee5f254c1bf0e2aeea331afd1cf151fc5c6fff7ca42cae021b2b880cf76f4f0367c3336eb55e562e77b2ef8f1759a7a1dc689d65327f8447ca8b0a04f5a9ab7eb19cb201d855e85be2459e47906405b573e43b0bf4ba96f1edd9c794b96dadd18e0c65bbb117f8538dd8ce7c18e570f967da4d785a669b3f3017d1eb91105fb9b17cb246ba80181f7d66edf5ebff0f44c23bd8694a1cac9290760b23954879cae8e7de1fca903acc2b70541f073e95814c4c8f5bb366af9830613ac49e7af7925ef7681e18516f0e9ac2362a7d0c366f0bcb4d3ff3344020951c4efa705af5d707b3d37795d6402b959493dc756822f49fbbb7b627ce8a09d446366cf468d9a327578b065b1e132804c97e1cfe0bf39bc55b30643d522175678816dfd406499763ca86c93f79660af004a7e18d046c02f8bd1739bf52d79f57c176f82465f7e858a116ce7f1486724c95cc064ed97c2e0bfa137200ffeaa7e1db00c04421b79047f4c9aa973fb9b16466e9634db525873ce98406a8bbde1ccc8ce052300f493c495a4df26d9ff94eb8969c3b7c6e77341703c4388a12afe71b2f94bdbfda4b1ee98fea52700f49919bb5e11a0fac898f5964ba71e31a998e2cec6c7d5ee53b456058f6a141d83a2fc3baa676c9526442995c15e83a42b6c7b11f1dd5db81785111032c7190258f639b23f20991b26672c0310537b49b4b6eeab338d53855b39b5277348f6886c907ca0d94f330c9f6292abf833b2f2d207ef4b106e631672183dfb4b3eebbf5d8db5f73653c25872a6465e2187e0b97b62c0122fad0b35c2ee2681d8bfce3c3ba1e2a31c51f03f4b887915e22f26fa9ed3f7b531a066037f7fae9e8f6f44bd60585ecd1dda0ff9ba6d63364fe95a3a05a878c5f0ec1aefda8faf2e0f5fcffb6ce0c00799339e99d963b1f6dd05760d56dc8b4d45cec315fdad7f00b9e3ca0feea5a3b7da27c9694ab848cdc8aec73093146a645ed90a62384836e6b861502247dbad254a7a335c727700481244929d579323b7ac1d93afba09775463ba8482cfc10c867f86a1e94813d083f18415253ad6e1223ec6d5f4775120e4e5022907be8eda3a0b0f5ebadf3ec06da4248834368d52401ab39960f294173d742a89f5f82c3fe94063e8258d22afcf58e2d24c9408582ef65bbd90924a2badfa3b5c87204187ca528fa873a432d07fcd5500c509ea063bcfb481cfb95cdfa586781cb85d118060a628a656fc526257c7d090e35e08e5dd337bdf218ab1e6de77958be000b1ba50bc0f18f698750c4fdb4ecf986fefc05a5e76fbf863ade803008db93c7ed35d548404b7010a1a85da4920557e46e605dd9d23297282dd80dd57eaa4bfc0611c43810c2d7257d43d26d904cacf8d827c24f936cc2065f3f71c9c562083d117ff7ba3ab6e8942997b41a2f862a6a93d2d64d7a02379afa6d79837d7fac6e4662bf2c2beb9492ba63d61afb96fc8756ca03a49bfb1a32b846ac366f02969c3b26cd36275beb8ec0a31748007339343aed0f05f069521bed94826b912ba38543d7d4074720dc2ad762d04f075166832d52525214e6e938fcbe2a4d233fc79c1b476c49250685ce4b587b71c3fc7d66f9647cc9bc1f60b96aeba82042d0ecbb51fe331c401d9245784a0ecfd2bf2e34f5a4748d636e9de8e82ac8cb8db6a7bfeb6d0d40eff35e00568eb26d17e52f0f65ad5bc7f62002e0fa0972746a69fbb02145bc8931ba916e63a223e74477033b2fb0fd9db12779a6381ec02a9ddb1c3f9df06f0df6170043bc2eb7d0cb3e6fae27dae73b99925eebdeba1dc734c1c820009eef6228f2befce753f1651fca9866c2cef1e114f63d7e8efb0f856ff54a991142a608fbee8706fcc025fc2af62de220b789000dfd787cd9147266587f790b935954978044599554e8035557dd4ae4da6a7c8929b2e31147ca6b205f4c253bb1f36f5538559190e93e455f8d7c4ee7324615d486fadb81edeb79ed99489d0c45f27be25ff5a4a4c680a983cef5f12d26bca18084ba69f35afa26599b4dbb53756c0dba3c6f24fbf058a30e1a04e29a43d5114bf507d979c19ba9596441e3b5fd17ba7e47faa3dd3a56435ca168056cae9131f935ed303d3b28b493e54c555a76e181108b610a452a1d18d85187fb64f3d86058cd68d14584bbad74b29eedeaf2c0f90a379cfcf839a4765ab3721a36d3b3b5579d5d4d071309f773e467a9cfc9019e7ba4965532d39615ecb48348898b7937cb74780e81c1bd0deeec6b2279685cd157bab3ffebb9e51703d5984004cf600668edf2fdaa9443a090bf7cd6cef1d83445c56e7663229574d2a6a6cbac335fd198e6d59860bf3739fbfe111ad49d244e8d0900fe800a42d3f42462703a4725672eb2e0ad80364c52008e82bebaa2e72efbf0cb4bd0978aa12f4d8017cd219961e159096b6f8f9dbe40deb3c2eaacea7c74ebe1e01c23af559d01bf0b02dd6bc46496eb150ea7cd91dd5d4c4573ee20556bc0a4dcf318ea7deb323aa6b8ad041b355003d6e1c832d2cc03e3d8331b972f3a13e829ada8966a2056d4c6cdc0e51f0ab554ed4a557bb95898be0f93c64d0ee21405176329409dac7faf37267973a625c95d6e20ff20ba1f5f8ad94c438cd926339126752f277e16c1e63814411e2be29683cb1cd896fb8476ada15be1cb3b7e4dec568ea8f371b70ee740cf6d7b890a93de55a1c86150195bd733b19929eb20ef03f4e7a1c1b6945474c33b377d149b3a8fa411f975a3688ecaaade7cb8c039fb66bb4034105c8590f416e98443b77d6bb82fcfe9cb611e6fe92e775706c38f6c9b1ae429fdae6fa207901ed914313edd4634f8bb68f36735e8707de8a8dfc15113ba1ac6c8fa9d35bfd9d5f0aae4cdfdc0a020b8efa1ff9fb9923789d1d404b047f45898f0f53f838b3df52aafca67f9fd3901c1f25bd6561c1d7ef03c13e0efee586729eb51f0e59c3177f4b0f99bc27b6908c7767af58a676b80e9442599f153a0ca4dc9b261e7aa7ccf22d283bda757c1663cf5ccc82cc8c5b121ad79f09230b6f2a53be63ff2c014d29b28bca89bab1d37373941ef2098fecd8ffab8bc7345169c43b155f6cf8a009202616d0c9595d6a6cebac2e658050574d12e744e6685cc1182d6daa298fcefafd8a494c64715b27df0462cc38022cf3eeb9343cc7c46244654726d11f87f3c342833f1fb5d2c16ae159a5dddef213fa6f9cdc58ca7510a616c6f877fdab6f0be8d9725127bf42002836ba286cfc67242e649fe4555f700f03562201efbc17549ae3d62abd2543bae60d5426f9bcb34f222c5f8726ac7b8ce1d7c3c2e01f8312e90cb7e4e8bf4a10908ff01d58bdf6b7db7fb334111b92b7d7f70e2ec04ffab0e1ed4ff3a690f0b7a3889c2750766eae29e92536618ef43e821496e3f251b35e7385e1c80399d253e059d8427e143043adab1dd687876407d0cdfdf1fd3ced59f3c847a1a3b916e343e54f0bfa2b9079ef33a1e0c3460d4986382f8728141dd0f7bd66686065da8c6f777f48835f0065edb33ead4a2223c3294f5113710961b1daea3d15fa42a31305194343e3c43aa2d4f2ba9b429b344f641fb5c5e6054cf0f86e9a9a728dc5641204233cd0493e3b6d3d17040c8339296175c2ddd868fe2a540c520d4e82d55ad170b5bb08326fbca5193071dcf0c417a4a13574fa56e27214388343604efce95a0c90c3daf78bbdbe577607585b545a6e7ab6b469556e7e39318d146c610ca6f636aff5245e0510a4d90e9f0330f7bf7e576845aab131dd9102a34653ead3fd3a0ffe4f766bb39ad6329330329ede9465e0aa015973283e45b40849ee6d5fa767c1b186471764e4aad2f685817b6d9cfadb532f72c008e229db46e22b2853c92fbc344143cfd6fdbe13e898b12469247f3aacab6ef65b5b5bf418fbda5f1cf783db1eb29db598af5933b47e4611c46b8ea9cc9bf4325064ade8205d3649008caca00841f03a99ed79ea881d519ef3b3addee18f07a68d8ea4637f538647601b3afa1924ccf11c65e367da2158d7d207052be81fc8defef15040e47a23c4799499d3c61f6bdf1de2933dff216eb52a7284a199e7e7a196ef023553565243a1f584ba837f200b951a5c2433ee629d244b2c4a9d95d5b822b31266689bf6828cd36c8117cb2ea54ebc3757ac10c1ada35fa723435b6ab73745d2e5d558177f71a12a9681228814ae3c3edb5815e7e7a5207c25cef7c39a543791892abedd472a50cf7648e007a6d01a13fc370bfbdbf8f7c5a42678e2c7e604d149e42febef7b839111e6df960ff106d54264d9a9a1e647e9f4917ad6f02c824088c21527620c6ae0c643fd7ef01aa031e8b3768365b70b09a7912cf5216c18497dad1c3e3fe857e857900b25c50a5d2ac8e24b4bd30a53b074716a8cab4e081550837693eee90e95efc8fd1533b0d70be819d56e3c8f3b3b79fe25993378a998c7c4fd0d471752698790196b5a8386a7afe19e1e8a5406833ed67470bd2a6728aab603c99574d21555bd63e2b55058e6c3478a3ae5aae08b646f19fb01beae14be104e9982a31bae4c94deea19b69fd3ec3a4315e4f1bd94d41b6b11b001807feb190f9c6d313f80ad0272cdbeb37127932755214981fe12782c17c8f44db925f1d72aec77c1ae38710aed91f0b2b7be5b1c44de24691d32a2c014b8e4baeef24d1ded7bff026c4c1d268f78dae1d85e59e0d65f9101ed569df270016e300cdd2614dbb4ddf1483f81ba4683f1a28e92460d6f037bac5b751f729dd8f5ca067892480332f6b12f7c108d66e830aaf4ea7946cae5e7ca7e8890d180407ef1ee76903f312abef241e0d277b73943a108a44646bad5187a518641924fc0fc245b30129022f8a9be0759f81344f849d8db5ff46f913fd62b9f6ca3e1c72708202b49fc37f08a9a43792c7c10a0b3e74529330779a5f71c929427f29421fe41e65e1144ef601e7be73c5d564e821db106e5023890e1944c995266c64e483208a4f9c1ff9ac6e5cbf2b4bbd801182313d31c0559bde0e154acc213e25ef11f42caa1c05598a8338b98a51da2abf308262485171f1d7e55bc34029db3adc1a039e1e9971729d088dcd02fa701574b56bb97c2d74305a1c113d7f04380039ebfe0929e64936f62beca73186ec34bad0d90f3d8fd809267dd8c8fdd428911f0eeb5f54c709f8998238c02d8047a20b6f17fd4b53081539e94311dc14568639a0e7dd54f5851c36e3eeb50ffae417bf06dcd73ac24896736957e0311d2ceeb50a1c0a0a8e5c09155e171da97ba1a4a10d1283b93c0fa62f94e54de5338724c937865d665129a2deed0ce4228fd0352e4996881864b63290dddb53f1e8a9eee2473e5a27a4bd3ea73809f4d61ab58bc80896b889ccfd61eaa52106c424cc000f53cc2d8b4246091d845e12ad0dd7f4b6d6c16a47fcf5a277e9079809db2b005c5178f786bb3b7666b360304b56496d19dcd2129bc6d1b0a5605aa536935bf89995d6e71892ff45408731c04cb17cd856c17003964043fcdde382b687c09026dd557345a513c016ce398e554c9f95e1be6a23b371b58b79fd9136eaf9cb77574412b158a34d5dd849acdbfbe97c8a0889cf89c1e9502c5486da5f287afa9ed1f27254c3252240df5e7bd0551ee435d60d4e94800724667c7b23bd791aa945870128596c1bf9fec7a732bedd2b0f7ca20d7e05ecc97f92c53c1ff60ef1967fcb2c120a465aeb1f5487d709bf5248de870bc4d7fab1559f79985b8a9395df869d964082dda5ea0a481e1945b753afb95e0e8391f66584cf7174b604b8b55b64c1378fbe1831f737c1a066b1e8894bf6c219a8b61e8f59cd1090a835fda8d7b573f12626df1545a115a4318578d59632ec4b56e4199b430d5599e910d365465d20a0a179132084f960b2a0c086073e6b38323e5b13c1604e03ad946470d2ec6bf7f670d547784b82f096c79b52e18d10bd38366be4dc3220a456ad97da0319901b932a02e7e38ed89664501e219175d6c80f6a29b259999da8ec9959b5b8af8078499cc563dc252a2d20e7577c5cd9687df476aba488b99ecd2fb9babb46f059a0a43b0d0115e981c32928eab6e5f7c27d0cee2ebf463695a1f7cf3eb7ecd0aa3e1111793f39c315cfb0540397466feb665f411faf38f94b79fea23dc1863e3225af89af06cbbdd4c581f5435993b24a6c77dc2609ee6c96a2e659e5e01e0bc4b9aa2ad1ef934531538c173542be4f1845a1d40d5c66c16ccae6cc582b4ab64c17ebb48a7351c82cd50519365809f34e8d284a43cd088d53f3f1f569f50d9b59a6648a1f9243383b50cb94671b602a39bb95cf55507510ed57315c59822368e6d9906dda9ec3bfe7cc368926df5def94d8f0cdcc3d058625554918ee4d7ecafd2dd8858c9d6d0a6fe0f0010a941fef205aa1e3ae79b15ff2c2be1fc06833a4d7872793a33edb02bf0c2518b787495c8240f3d3653070e2f28a5396aa2740d177531b2766e1ea562471dff54533975b29d54e9e0e544d03d83d41798deb71cd59ffcad9415b11f4b02ba352d784815e4e3e82453ddaf31b7da6e8d7f8efe0372e82fefd2844e8bc30d70fb78a341bb979fce65e7b21e34b277a8e08f79182b32c06a0efb23e36dfcf92a007030a13732be4da38a2bd05e16feee765ad167aeb514aca355947effbf3732bcb161fc1a5c0cc0a645c5c77b4c2be00b724e2ec1a643dd658c28e2d702f6fba5ff0e6547c45ad6a59ed253524e7399e1b8e72ba588d01b97945a48ab7e06dd62bc7b611d75e6b472f3c5c891e3c4db92d695b2e181934d53ddf0d74b8f0aaf15e2e5db3ea47a8a5c1f53976fb22c9e6364c0f25c9f0d2212e1c273ca2011e5c4fe33a5efe40618c82f658e86c4c7f07842caef4bc59ee10f541e9755fd1272c5ec1425e7496c842ec1fa8a3b5454be6ba37149888a151458506c57c2689180d70efcf1204a99ecbf3a21320b2b8a0d338ad9f93a44657f7182972ade5a81c6c47dba3dcf67841940df8ad0fc0e819e7c4ad86c6ee8050711f40dbc43aa079cf72ba6970c20e2bc97b6093950f2b3b2ca9a89d4ae2005e93afac54ede48577a267f22f322283becf0228bc205930215ed174befcca6cc5cd5ea2a5957243fdf55338fd3a7ea24a38c829e4d0d8816cd57c5fe9510de1d6a5bd3ada170993ef7ea1a19a578159eedf1c2e1a8e2f97bb45c9ce1dbc0a33ce994c5783c2b2f93636b7d86e687c48a87329269e9385ecf24069e1b97941b24207bd4c353c7ce661a2576680af525a7e5e519cf364382981c67a3f265028dec0a3a492649a3d10dd4cc68386dea2579f284d81ab346857ea912e47dee82684d13e5ec4f8561de5c304c4445ed706e666ae1dd42b7bd46e5fbb17d69b5c43e4f8364c0173dad3a84baa778f8c9f4c7deab7daecc56a95b7c3d88a2dc10fbfd2d7e4ae3dec0c889a3305692067eccc0134cb07aaad8a44e415f7fad2b502560967c801b80d3089b269838684e121858b7683d45aebe7447c532873916e080cfdfd7f4501302e6950c23288ec00da8f1026bf4ae00849174e2fd9f1586bbf76ccfd3f279529a5a5306b4a0ebae18a484c676a5012b77aaee33b7de698932fecbea6a527f952575e45c8cc4797ca50b15ba708436af30280cb53e9824703f9b6bdb69c9fa0593125a49dff26a63694c986f3514aab905160d58296a0bb58641ec7619a3844c677a7f2b848cf8987599f8ba8cc56a08c5a4c9e17a9b1a9888465202687afd4b9b2d6c4aaa9e41972ef178c657688a6c19051d5ac8e7175a6216d44740722b954dcb8f33861e2471357e0e48978205a2bdf7e81fe4224b91e1ee2cd64cae2e5a2a9e82ae02437a9edad3724e3d1b202049ced7b75508120209ec33fb25e13f6ed6764f0f7f24f3c3c33e666aead0d155414ff302e445542df872fa4f056bc55f4e15e11be73d0f70b065c61c3c7e05f311aa7f745c0093fa3ed9734df7a39ab5d5f5275ef02e5f32f37f480b7171f72474e27bed258c3a36a3c6c6a8196eb2850b9e5231262da9629b8716ce6c4bbd93dcab0de078bcae5321ca552f300347f78ef3eb2d32f530a9332ba0132a990934bceceb9f659f029f15f0f07501d0f1f731d93403ca2716ecbd20d394b509d49d16058cf5b3a6d5a55f7ca7b0439451fb203b27933c9c9149dbe5f8521587656f9efe3e3393f7d75dfb693a5bd9e3957884bce1639f63bc876b16345fdafe9d9e7f69357a5a4bfed164a6c27d11002f2fe672e222676b5a5947372f7c1576168a3cbb3aa7557f3c27d31497638d9daa6ec845e3024da7803d7fe382bd7d5db8dbc081956140822d764e324dfefdae2c541baef3de953a6b763fdbad217f9c0a3dbd38160a4252f315b74fac67a242b581eb91dba7b5e9f69ddc772e0b81946756d952df7049a3e08d6c2ad50b69d52f52b156325b86638aa20fd60d87057a294ff524737932c47e44d2b8bc7a0c3fa55713f4051a7705cf0e5737d80ee43e60c44254ca194107e13ee16abe756971b6a1d6a040130c242f7718a966812231c8e42ff60c03978ac9553d455e96a55f5246689e36788f57452dbff0cd08fb9297f3474b5600d4f6bd6311e9a27140a44e66127fa5ec6276f8ff219b4a86e9590c8da2db5441f3221f4c30e86e079219e920e2a6e3017ed2153953fdd1236581066f5c40c4f7acdc3c6626abbdb13c1b22c666c84495d20039a3a9a1b7a02dc1abf56c4547754fc7a555d97b00a9db3b9d112f8e40a14aefc330f99ac43e3e54c8545ab86804c7d7945a0769acc249705f0a1da08027155cd5f06a99e2d21dac22dbe49fbdda631c57d0f3a675163cad6a5c058a84f09db46d75af81ec2d6ffb74904051028132258aa0ef4761c6888099ed2089d15d8108178436393e61e7230fd9e70fc633b44f15a12e545e920d5cbb0033b3537fe15f17bb42ac6ed803d57b4598945eda6da6bcae9a40a26e1a610d532dbee3dd4b882378e8eb85d210643a797e054f279b237d0f832b461093a0ae1b611c4d9796678e7d322f361171a116eb0185d5375068ef1a10e194480da235ff5e7d7d7c4c5d4066294d2cae48a009cfb5e04157b902480b3648494bbdf8e7118e506363e1138f3533bce8b62d7cbdaae75cce212518e85c8f0d573f6de1b7cb3074c7bb3dff5df6edc1448eed436d11f8f43929462f78bb98330369506b928735680d5b9671df8d4b6358a7fd3d8af638bc494c5a672a4a3e49eccbdfd5157695fc9ae66764c9a0dc9af880beb1d991c567c71f6b9c029b5234ada7abafb943657f4007075c43e42a97ae4e24a20e482d9a48f29aa4611bb266e83afad0859985cb985b048121722f9abc449471215a031d27e90b0c3198ae8c05400df0205d9cfd2cc7b176c207d3de08d42f223c54bfd3ef9aebd16926bc34d87d66d727580acacf95433e775a1fb8ffe934d04abe1f16c8798ae2005b9a366c2ca940440a6506089358a4643a87048efe1125d095fde2c7bce1f52aabfa454e37198104fd4af3a93b55833846df61a78f4ab2e45584a298b5919913bc8608358ebf1929eacfda2e46aa7107c1b290b8c369b35869cefefb8e4f062dc3ce04d44901b82f4f6583d2dd876e60aa68daada53a1577d875fd2760ee772020f1fbfb864ffb9b878b45a9c9a53627db5c335265cf82ce0888b2d6f9ed7843c34731f1858a120e80c3871733e86d50b3dbfe0c229d73adb13a9a0fc333c0272951b1c64a3573a02d035cfe825920d7df33d3b45e0bc56bb33d4a0c68aa71723d069b96fd35343f33cb3c847f9ef739772530625bfd22eefd25b52b639ef212008408527bba1c58791c8c2f44c09e5772a53b06fe9b76a408ad9ebb931b4c27200123a34cd3dd1292e1b4ed0dbf3d612014065a08a19a2a9214e72fcc0eef5fce692b0d3bb3c544a5a15a1908ca775af9f78cde8341ddab9fc8993dc9edbd7067da5a388238f34a32e07b79a7c32dd2b86664ae92a8aa382ca3e56023b45f997dede1ba276b704e9c1cb54a47bb613fd5f42a3a0a6cf3393c2b252f72cf7e382ffa0ba9c28f24e6979b7589d30fce7ca8c9eae6a00df9e29623daedf729ede703a28957b7f9c256ba1029ad3d52d4e8b23d2eeee1a1831eb5003edac92ed51e789b4b54cc3183ff038b985c83d79d30ccd7d094620a7d74cd12605d6f10def537c57fb6111f436405865ab1c5660e4782f14c3168e3fb82a582cbda93b55a60f63edc8a7a42064ec3104e60a50bbc2f5ec5d5c070045e5c1da20f9955b5fdb76a15c25b255ff03da2f7d2a976ecf917ab99bab0a39f6c353a782912c615a9af60259bf02703320e4a0074c31e0644f610926b1311e09d4dd07812a0e327f008e833128b58dfe6011fb7df8d2d9180cae17d301e253c4b05a92c2906519af3819622e56aa3e84bc091b8a6ba86f605d1fd752e6d6d3d27eb0c00eaeb0064a6a8a5406a8fef94480b82499393d696ddd7df8c8c39a78f62270ac5c095bfc6acfeae487f3243ff5764cb2fe58a1305c7a4c1e3878ed32387df08b63afd523d3711856c0d932253ad9602e490fdf1a4875b8208b8ed1c55364e9187df7e1851b795f84c199116fc7b47407734796c437d5757c353f38b4142e7c50e79c751772b9091ea1feb97631abd3158da26a24926a4043adfb11d028f0e46ddeeb001ba07fec80c8aa4cd62409ce74ebbe33de17c4e6d3a374e0af68665c581aa6efd98843d082ed1bc4f987a62384c3aa56a0a7146afc59c1dc2ed46fe761d54cdb1bfd42e63be9ee6f90ed91d355298295eb96f0627e0681a72288d77f750471da340b7e478e0e442dfe8fd872512be58e12ef6e5bdfb4546dbd9016fca4b0b043f8f484f4bed1d01a72a7002e5bcb9affc68712b41cb4f02a448057831f99f531fad41daf8a899a81590a8bbba030144c563a30f5dbdff7610c875b7b8475cff27af6df2cf3fc4218bcced506a7bb610e5c61a7cdb33dad38d715ab015149a0caf3d4ce0d6ef7860282bd3281920c9dbbecc2eb9d44476b35ef3130770f6b5c8368fa7dd3afe51efc1ca9ff632e6f223d67966b9c67f511a60d1a8ea33217ff87ac57ba5f2af88dd545bc8403592b2ea285aaf2bb0afb01685cc8fe9033253ad53367e88f0d29b73c4e5f34c7c0b412ed13afa62960d0e81ddaa604fca0d4f3d8b6be6a57ba9cbc9411c32294c2b269be53cfad73b4ef7d8f9258524a3a7a83ca825acdc2c6560895d44e1867a717d9f9e62c9ac57de0a935557f98bca61306082d26a85247c28c6fbcb0cecaadfb340d27e1a8f4b1ead134b7d6c69051c63f05c1dded088c8501ab40edec505246846dd132497a124e6d9e4a118fb4a0a30127d53255f5f3f2e42b4e8fb04f93667faa1ee560cdb4034cf483ec75ab4ff7fb9d597c66e2e1e6ea925e741df0ef65bee0b87b2afd3cccd787f5608f5764cf2184f25b777946dc5107374d3a2955d1b7d31712222871ad5c5220ce9b73ef1634a60b0fb90636ba14727f7298f873b585791919c3dabd88fef9ca981fc0da0a44ad776e5060922f5de51316a36b2538f196493714eb3d344ce6e9c484467754811f82ae1c3a2","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
