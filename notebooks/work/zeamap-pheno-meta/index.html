<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"46370a0ad9d4f2bfaa903778837ae0d29fdc16b12f497fd9af98ac19a98e79f1f558ea853ba797ac2ecf89fc400807220294e5dcbe73ca445a18c1fe503b881752a13ef83cbd9d1dabf743ef487c18b0cf6ec88fd49fc4285cef41161afb0262cbbac84be909624b528425480e436c540e84914c2862fdf94c93089439e36777d875ee1302c37fe3585e4080a01b21d19d73b30b0f53025b529ad225e72981b771fee3c44e2fda58e1ea51fd2356e6f8d33a138d9d1cc7508aaaa7b1435d74132d0c0ae4cbb780a686dc15bb91c53cf266400f73a983edefcbc88a271380e9d555e24a9b16ec1a2ebdede0d9886bb90a82c7511150415fdd45f02ee5e1fae7c766904aedf6870119783529823e35b87436c9f96af8c48341fda05b08bc249b6b56dd430a10dfaf1d997073acd5e757234d6a75745f7dfee4da1cb8fe1271591825ef5b8341f8d090d7be79db46de3628104c428efd2dfd6c3add994bb1c1a561e5935bda10457a658dcf5d790ecd59d24164478553a3652bd1ac0d049f3dbcd619baf7a527c0ac3d1467a6946386bf58d4d36ea5f500be9f7bb1bc51c97855964e6b846aa9714e7e268b486a7bca7f9d25c000e6dc6a9ed3c6048eb718f25deab635d4208cb3a50a2a4b28e04d71e98066fa6bc5eb150e226746fbc5fe46f76e07fe5b912c7e058aafa828ccdd7f6fa3a9552e206a91f78a2dc98476184a4a00dadf935bd09bd45aa1dde69a152a16a38ce1ed0ffa020c50c40f2a9c626ca7337e085dc4fafe89105eb68370fa2fafc195d4bbcda44d664a71cce0c81f07336821caacd848d9f94013cedf4d6c568a9ccca87c5beb97f7e6f7ef3ce62c926d5b3c837384412ce1a2cf7c21ede4f6b00ebc7e57a30abc9aac9875240b7fbe7cb13be2cc2f00c4c479b57b65a0adbd35cddbfb9de49496c9970af4919ec55234ecdd318a5771d790004072f33825d5e1823f7b03205b4ee178dff27bba95cf6a0bd1a55b6c81176837a41202a751d57af19bd471af20d3f81679fd5ac62e4040b9be1017934e0feadf93a9553f80fdf18d46dbf9f69caa02dee56cb37b9e147eb37b56ca564cba1b4af349eb01ad77a704a12d7af5c485bcd6b3cdf77c538d11a3e9e3f25e48ee9d660cc145fcb416b27a687df106d8b439a882412d025bca34b2d6246a31719c39553f37bf2149bc08653e483cef94554a06b0c0f831dd216025db3125aeb3adb07f7d542952f83e81aa4d0cb461e6cb5b2a1ad48b4fa09fbf0be92df0a5d67598de16d6cc3c929b3dfaa6e50f8dcc3392d2a18bb0ee93e9503637ac2b3853d0d53dfbcd7c07683bf1534625e897a1fc2c05cee29e6b165c008964d2e99eb3502e8df46cf45447fcbd4f622d3ad759613c35a3602b111fa132fa42085db48bd92befcff12d589e7785f7cad01b7c0987c43fba2301586490b9c21388c2c9dbf3bb736cf1eb97d328cd4c563b342da5fab5a7958d2623b1e59265460d06792f22309d47d9c87aca5de4a9104ec0141ae9431b13d8e5a027bed990c98d5bc6800e624495394f8b492ec1d0fe0454071cd51a8f9979c528133f6766888a4fc2b3de44be7b055e9834e8bc0e078a1cc47502717d96375f3cf45f0d6994ea8f98e7570b414d310230b532e025996628a4312a2ada04392d706279c4a33b7f3c7a17522f28b92968c926f01d9fb11ef8e5963e9d378e9ab9f484df905cb3a8678315ce8792914bae8ac8620b59e5cdfa6c72961f275c75544693585aa4b7e72c6e367b5d20083bbbaed6543ae2dbcb8d891ce5ede3bef65730a1f999c7853d4052cc4337c4c87b96aaf958cf55e2d052fe2a659e49c9ad4f7d3620182823b3dae989ada2ed7befbcc73bfc44d959230c0b12999175d9e536065816ee382315db8afec2acd3b4740856923d634c613227b0c01b1bfc6738b4a6e8bae1bc2e9d34f23f58121d0d835a938cb7b350c8c9925b2754bd6b4edee89a06e5dec69a0d9a5275f7314ec9f26b362230718e55ca8782989f92f65b4095963f83e604bfdd509500568dc4ee9e42db7d7a30b86a2f72401bfd3e001cbff40220d496d77944b14b447e98d835541283a589d978275e20373e04df338fa469bad546d5e2f8b6f8f3678e9869e8e40eb80751a2dc2465a567c2c3ff964843ab05b93d18c9f1cdbf73103ab4f566494bc3596bf584613c0490d24e1f36ac8ee0ecca155be318385c311eeeb7a14de7f377b8deccbcd14370f90d6567aa3d1549aa6719f46048a52915525eb6e8d069f79205bac6035a48a1cbf1f19b9c05feaad6871a74ed8c1272f8c25a128381a3ccdcbe665335cc37a47c030f349b31aecc737fd171fb2a2a1ab1358457863387c851ce043b49629d0f0275a7dedde1a60a4bb774343e5569096d38a24795a18e26adbddc8e50728aeb46fcb97440a15b6d6a7a040ee06a8cd3c9143d9e1c3a43ccdddd2372f7d0204f53b1142bdf03cb5b4a9b7ccf1532be7e13e56401235d7543986b3b3b51cd55a194d0d717190809080976fb2900827604e5999dc936a0cdd942502cc284ceeff6029bca3859b7e67359df1bf3faede29b3b86425621c9dadc5762d4555a29f96ae7cb9b6d6efdcf227f20f25d451f4417b57b8b9aaea4c2cac72748c7d0e205635db508b5637d5414831c837db60c43f657c829665bd7b849372d68e33ac91bfa6cc2b72390b302acbe7febf5973308f8d1589a7d53d4da2c92785ff70097f5c575b3f71eb08adb3e07638613dcd3b29fbeb47e5de25ae277d8fa9a7e6bdd7b4c6a4ee9b593366b0ba3c03d24940f119841d60ad708e068ef29ab6b78bd9ed4a818f1206910c401414c39b968730b40a89b0bfaf4abe3923fe376b8dc56e8637a659161486444208fa4d71a4e97f0aeb1bcf4d4be9ee950a05082f06dae5ab9f718aee5d9ac4175e7ad01d8bb12405df3a73c717110b1628ab5680d4dda7fb5d7ab4f004b20cab5f61d796d8181f3c94947c5a47b72a4de44175a6f03d96b4d4ca86f8683dde0597f184a51b74a81ee888efe212c2307790bee5b79f4c5789fbe5af4bcaa05924681a7ca8e20772270cab593a187619c5e01360fe285c4785916c2e1252f8379336e432a747f8db3c375f92319f2968b4326d4219928a959ce29353bc6faf0ae65a5fb873f88299a65dcb7a86eeaf4b8dec134ade80e9f199434ac6c737d86a86b55bf30b43fe55de5ccbb15814876999828dbd1f2bbf4b6197ce9b5fb719cd7f00d4ee55196bbb35653993c5cccf11bcaffffe0eceb8fe8da44d45daa5df01e95032ef46fd03b588106a6fce89b35ea8cffec7bae9a415ccb30d46389e50afc803f2c9cd0ff195e62f3b5c8d6547844f3265d6c1a3dbd53e059bd84306da963883e04bd87a3886aebfcff33ef12cf2cd2c9299abe2c11b371e7417f90cdd3a14a9a12803a92505a7435cd622f8466cfdbc9e72e1389532cd80e0f287e4eb4028db2f9b51922eac54d5404f5d8f73f7b1b5c82b24cba3831b828197d6f14f0bbac23f04cabb715ff7841a79f146dc50f1ac96672cfbfc77b6d27f0da1415038d630f3facf80cf06c835f34896039c8f25b6d4e75369058f9b896683033dd74438e2af79d63fa7f0195e386e82038cb712e177652f86b195f860ef29ff39a6f6a2ef0233ad515be995845c48f54f8da8ad4a71762b5ef080cf5b84346572d9040c5ce84f42be42254fcb491966b064356f48f10b53d871390ee57ac5a69bba050ba442543459494c5af481593fb526def932ed804c9918a6bd0a01c6888de3c7b13bef65d7a71be3ca82a3ee9542971aff7517b0735ebdc4f882f7e4600f7cfa7bdc055eaa159649242a59603547a12c00a5e6030432da17a324b1e95b7e39dbaf4a51720846fd6b8f2ce471c0436c82756315d8da85d025254c91257882c8071a30847edeb526ce460923ea73dd68cae5a4a56a965cd554b521bd4e12a926489b43145adbaf9522400f721ad6ba17b1dddfb1e264c18b771fb5c9435d764b2d9a8c35f1d03d1af95919c021aee7b1535b9c74314a68460d2bbfe19ad8389d9b23eed7cb65ff3dc62fd39e74cfddcfc333f698924b037b024f168e2efc055beb3025248b7c2aab12845ee7de580e87c577a4136190f1617a402f72ba1eee2aa7251843e6ab0b4f3a28313983e4dbf23660b47f7658254c3f513c702c70073a6b20cb2b54926f7c1c53c466ff0f6fba452b349d5b7245849084ceaee9c9752256f907b700986725cd19b4f9e293b21f7f17090179c3955fd9d2c1b4e69c060d15632ace4b5b493aac479c4f15c5bab963c864558ccecc0ba44732f487bf3dbb3577678e96335f111a8fa96a743cd7bad648eb1168b001bcec0b6e3eb1536f03aec184d6ec69d821e874a881a17683aae5fc0d370b6ad51babe574db29f2a42aacd1512bc8e6e86c830d7645560207968390f757acfef018736c023eaa9a9c05df4e22c0c6a9f62875a03bee9a09fd3c1f2e18ccec65307ed5386aa0e8394a0fbdbd2aa273f6c9e92f10e739fdf498ea490d28ef771888144acb80db8e5f35017d351ccb7ac8e07bb92441d1b6148c1f8461a380c6ea2765ca0493a9e208bc54639564d704bdda810fc7ab74b982f84733838eb039a4ef1c844351c6983ad1084fe853822bb7f14f53ea8cbb8d061165b425b9960217061b5b4ca38c2064048e06f1c87779d75dd1807bcddfdd24b23fa1b4053ba47a4ceda6de43a05cdcc129b0a2ef1ddcb3300a6465a6080495136552592ca87c55d60ad0dd775d32df38cfe1b48ba3d6df9dfe3b97bbd3d5088400553bb6580a69388c1f9b99415254548f5272496107f713d47d8a3db2bb750815dc0d09e14a9c9162da6f70764f744aa8bf11d1c68c82b0a4985da0fccb91a864ec184079d3b6dee816d32aeee288be9fc8b759ef7b69c6fe3d3e4687b759839f8883674851a78dbc83bdd5c98147d0d4092155006628e5db3b26d705e4ec8503a6341ea08f686ede5731be0bc2f205eb395a8fe8b75284bbcae93911503691ab8482aff292bda0c49ef56d29492cbcee78990a36bbd5c6c4372b6ffc5fd8039a65bb16c0505ad70509b708ae9ac93734a41ecb411f0ec1f18433ad40dd39fb340cbd3d94d2a969e78d75b8d2975a2cf36085f0d1bad018f7f503513bbee58c06adc5dbb735087ee125391c7e4ab488e358ec320a79da03bad00d0b2b5c406ca6c873182ee9f4921cb917b42023c41b37e7e87135a5aa750009a3e047431e93d8b043607b8cb71446a404f9ad301cf8d62f2e07907d162dcdc80ac84129439cfacfd8cb83e50d60c8fa2fd750586dd618a5d57c1d8b66fa0c06c471879f742c65bd3410d6106443f96bffe6f0bc2df96427e25041f5049a3f793fefda2b2c3c7435e95d4110547dd49d6775c36c065fb61ceea5d650bf62d86d04dedcea8b41f5db84c1ee3602c0c236fab0ce3fd43e11df54fd607f5179e8aa9dacdaad3ec0555cd68e0ec9fac6b68700f19f194222c1dc4f2c23128c9bf3cef07ac2e8911cada08bd5e1742eb974328cf1503a9d070a99edfed6350b9e5a068d4863f85e6e281abc5f220eac8b39b2a3c98f7fe2222f942946ae9a1d756ec01a24cee295ee1e307f35630b53ef8f9cbb6f100054b3ecd9b8ac830826c4f94c2391d5f7470edf9533d5577c936dfc0836a0cce334c513d1a9b7dc1f76c54523365e119e210d075ac8628e5f84263f43d5b7a51cf4c1047190a835e7a9d6849b31384edef0f8cab45e9f77143b3ef56593e759c8a4d09918d2c0cb9217e905636482ef400c2b5d9e4377851da1163999e770823f6d7506aaf4a1face19ffbf1a1f8c2de62d86b219a032c6ed7c3e701d03522a3337d5a5e769289c0a2c4de737dd37f9544766c8288d2acf42e385343f1c848914ce428290bfd1fd26d201598a7819bc77f07cc008d4bb0874fb6bf8e8485ab3df3f33a6c587ff27a16eb12767214a2ae31f030b7fa246d58c929407e57deb80d5188bc86861edf49f84c8440f363eab34a4a2d67b67bbb824f9f27fd4e7433ab5fc38472524e5c4e383013ee2acf62a9a37388f26e376c894b26a9750296dd5efe9051cf1659abe6d9a94b3b38eb7c5267fdde1feb8f43a27f3e7b62ee319dd113dd31e8735ee2218a00b69a3fba32ce9e0bd7e62cd3cd62c375e99d950c8164bb08675f5c964e1caa5817d7c2f067f466bda5e33317df1fb895b46229f34d6843943cbe78f113a5b468850f6e2ea547a3467857bad98a95883a35fbbaafaf56ad05194caa8dc115a101ce413e1638863b5dfa4830593d0898a60a4fe49e29b3367c7c45c2bee0218f6f3955da8e75dd6f6ee0ad95450dd483a15c3b7a219d8f6fbd6244a1a8d2925f40d3fb9a6c33d1d12fa4ede8fe03433d77d553fcd027fdb96796894f87ad5d5047930053c261478af0e0d7fc0d3cc65eace9e7df50e27d5be4ad09167534ca7fbdca2f8b0c67112d48564f086ca785bb0a7c48d87437f8caab83a5fc7ea5392c4f8fd2bef8ba4cd3c96e14ee745b41eef22ebc99f8cbbe263e4b87aef4ef56c1567b541d280425879db2846b5f1bcc1761d56985fed8be1789ed9e4592eec7d838679700417c0f0c059477e91ad836e6b0081c174dbb1bf67387dec498925b0ce137deff6eeee87e2331ac515fd0a6f87a718f1cf173e04eb01f739167e157733ac13c82963624d77feffbc25901c063fa3380356317005552750f8c585e888f2a25459693d6dec3217101ce76c5a20193fa18552d833b530b872f89c3aca0c08be7462316a7701fca8c9b8c9cd3c3910b6b72eeb139c7a482235af9488a25e4c47d8a4acdd40d9e6f9231f148231df256f627ac0a06a98cbf73c3dfd28acc2ed11e29f7525f871756ef0f12ec69ce58278caedb54da9222cc864f808ebec819c195e5e4a969392d4b8011fb6d395eae43c04beeca962a4da8dd6b68b6ccfbb7a45f5470a033660d5576a3ac7f3a7676b086dcd26714d462cbb6a9487bc4787789a65bd9b13cff58511e90e35462df199179e3374d54ec67e348c787fcb1e28b93c34fc7acdfa1020f8de0df326d670859c1008a8d4eeaba30a6c5cbcad263d73398ad5f3e17234cc850d23e67ea78812bf6ba17828be25c8804c729961e1fc10fc41a35edf40a3aa70e552120c85379c94968ddf25b269909e472c685410500afdfcf48fced8fa0bea3fa57eb3d6a2a0da6e0152f01d0b2e92195b58a009c84b24626c7d351013281aef4d7ad72e836bd8dca6f3f9d3a473cca1aedf6cda90419ad45b1ad8834f14f649cf7c52acb93bfe6cefe1d3a788c4bc050bb14ac837d9d3007930a35256a843416391b7248e364ac4d5a92cc606fe5add44b3c4e59b70b2b9228f26831b33c49197aad0710466210a0fe852042cdb8e5b5d048881682a5a4b4b01112285a1d3c0c184f9fd164f99eb2cf390ef3e90e0018625616bca7661835aa3f02364ed7f7a152223f1bca25aeb5ccaf848d58a3d54a9c95056d90026d618c366b7829a469d1488c324578bf0d9695c2d5c300cba5dbcbfed7985e240a5beb8956112d2f1301939b9df40747d8664f148588aeec0f7464fd81a61261fd9a9a610240939282b3e94c37a4fab7db56100922ad1761e9cf295921b35a56cd5e4dc0d51eb15f8bb8d6569e6632907cfc868cf518803986c8ebb36eb85555795ffe15aac153586b3ac182da988f76c99020d8f0af7200f412905c9087bcfe84fefb22ee48b3a314d90fcc46cd1e3bf5b0b41e70ecd3dce467cc670a1679b98440a86c3132b13234fe4665bbc7be214852485fa5073ed627b9322e3aad253c4f89d273e712d8f02b9639b3a0c0ebcc8fa2626cd4462a9916b949d778df6b59bc5ade98c50882935bec55bbec1dffbe6755cb39972ab661251cc6d9abeaa3ea49e7f8ab937569887d19788d4404988562b26299631887f08ee3174b162bcde00653f7e1fea298869a7eb3d7cf542f1f696cd255bfa076254af0c5c177f8b192388dc78c4877d8b936b09ebffcb044a541897cb782f0704484b3c9f0fe8edc903c93cfa3861fdc74c45ec286a9d90961f126d9909338a78ee4cbbb34432442808c44d3e526f5770db3388ec27295242f01581f4d0c918bd88a740fd7192fab078be5d9ef169a8a911b0ec4b851ec33cb40bebd5a6eb83460477566aba363971e59ea9dd742ca9ab0b3f47f96ba74dc8fc890a1f1d2188b59172f510947cbffb0e9bb109c4d3a181d5e9bf04753e28b5ef4dba45300bc5072a8c8157fffb68f701bf0e8f3b79defb73dc5714a925b66efa92ab06971d9121d45423474b6659b40704acad43cc6d41055806a9fa911f3331215878bd6f449fd01544bb0f92347b71a17987bc7afc1c599df459fab0e8ebb12224dfb1a449f99cd803338ff720e42cd406e90559cb78dfb6bc33bf9caba0b1dd8dfc1b62215be39142ad9a3f057e72a3c7e7bc78b4cabd486334a47382900f04f7685dce05637bdbd3cb6bdd55eef34358be761ea11f68131972aca4270eb86d892497aa7d84b2d4c6386dd8ccd44ca14161718dc3981e740b1f5077c94ad0860058b4009ce11c4324092c8c1b70f3f8aead2267c5e3ecc2d98f23c26eb98998c22031af31d16321b534f0fbc17e6a120d0c17a963c75b341c03d2f1693f8449f8b9623a1f24f26bf6bb50fa9eb144b4f076f42a3d383ad011518045db8f94242bdd063e2b25eae0a1dac31c7024cb4f68eab0eb82f75f157f5ad60a0485e7451d73dedd4422626ceca84e301aa5a7374401e47ed5ac76d886bc19c6062b150a80e4e841ca7ca92c4d7e16ec6e036d6d3eb004cd8f0137591760c3547686a10e6850e79fb6e0766d5e2329617c1208c000aa207e96e6db6e5892250ca323a37463d19f94e0b27c734b61a4f14fa23f1389995786f43e7f3f4170a6a42654963c1b3195c35fdc659ae24f55a10727e2ae0b9bd291b32cb347c249fb55f8eb5b77a7609e16004ca40044a754ac92e13b54d982256482eb2fdb6c0ca3df4faf4f5953360b3c2e32f7c7cf050cd8280d52951a03313b1e5eaf8e8efafb03147561948d8a49708dca371472847a6193cce57f487ba991874809aa5b370aaf7b67eb3edd5cdad6df66ecec66956f5ee019c2645019966a54e1355fdaee709d1f2581ff83af9f55d1b05573079b74666bc48cdcab2bba7b02a38d70220319262cf92f5eb1f3cdb1756ae97fd2dd58940e1668c1dec3e59c30bf1c0ceee677d4c014b7a46a1bb83e2ea6e8b37a05c21a7318752df7f1636509fdaf00c3fa59999d818946ec8e2df906859dc2aed62c8a0fe61da15b32d3f48e57cfef4e5401f09cb7be19f1cf3b356394e5fcc195d52c6175c0824936c76e1cb7e5f1bafa6c92e3dc94e37b92820ccddf8662935bba1a0e6ae4cec7ffcf7045caab13a3b7fa5f31ba104ecb3d23acf1a3d7d79797dfc278db7e0575b4067d7989a5010a435eb32eee822271dd868b556194a222c5b0066b42d08fe0a4ba441e1baebcc37a826c8c61ebd6f398d781b31ef2d1b28ba191534347b67311b1d7be340a1293441128d34429d3dea70d1796edc9d43dbcf5e1e25aca3f7df35f3baff67f48d957e9ac57ad2e134d367d8f42537da802fe4784b5bdc5f632053b2e6808e135188e75b86ad22d7ac214557ea0d8c278d839dcfbab609d4bee49aa4101d78f0712e79dcd22ee7399e860a4a74eaed4c5f31783b0dcc3ffdcd895a82c3380ce89d90bbc3ee33e8d61d0e4a4af2ad7064c082d90c4227dc380d06550b6c9d1ded895d441915917452070d72235e3dddace4e110971749011d766ce7960ae98899dc2d28cda3c941e72068764c58842413082d5dac4c7ce5d55cd1ef47f458f55d0ac48f670dac7da4b7b3d74dc4f20b793d68334a90d9df29c5b506f2b78dd0380fec90f5635626dac5654fe16f7fa1513fe8b9eb8240a941637d0a560ba57ca91b22920618996d40c86f6cd4326569bbeda6f9f0d22fa13a2e189917265d76f09897263d39b67e9278fc7ea99dfc2d6ca9a241a579740e10225075f0be5f1c50f549f3939085bcad48be6dc7cb71e9fd65fde51aaaa175f30784b37294b365af62bbc9d97f6544bfb154dd61372b657990d5a8299dfd4711f9682e27a1330021491ba420b92df45ff7d4062b82d4e3d2220a223a966f70ae2c292a82f502dde0a83ebd08ee4e23cc63adfce53006cf08a4e6ac7d6e2543c3305940300317972e3746370d67c9c10b3cd83caae69aea2a8b197d51c58e728233e2d72b12a7bbc64d69367271804b3fed9ceee0811e5605562a2ad103d7f43d3f55b79b7aa0f4cfa043962a69f424c1affb8b3aed451586ecd57c94e4b3158a7760528d4fb54ca8b72031369b92e09557e0a045d210de9af330b6e17f9c7dc0c716ae636b0fe2ae6be24331b3710729d0145ebf91c01cd7fee9c80c984b2011f0f2dea976a32a9fcae3af4d2a1d952be721b4ab63d908c9ce2a13616e43d941b0d6a1603963e08d52f7e3d367ffee459c84c43aea42464f2a4a08bdfd728c33fb6a845355b9312b55517354f59a02421c4d6f7cb527499385424f7b99a14db905dd35691f3f1760e1ae8fd0c56aafce5b6f61bfb55690b4677a1c0e7335efa9c75d8ed4cc23ab18329e42ae455701e86dbadaefa9b54bc896efe2da71823b9b5e8149b226e57bfd05bef0500810144290dd34e6b989af0e58a26379cefe04dce57c10cba8ec9500bb71ea863ac5830364e71e159030a960951e2b97b155c6a6f8d0eae87108651910aa4cadea61bcf39f39731a7fe16ccf479fb602b9bea394fa9722fb62a4745a8e7d3ed37121958259b90d11635d7f51cc1a1c408b6252c71808833e8bb7c0f7475816d604be0506b3468dc823c4edaab0347354ff3635cc4849fa89421be8d74253cd54d2febfe267dbf20354eb4caac8b1bc5897310de1989a82c6f68431013f10f86966d23c7bc0be25e63f12d4c4bab3cba5853618535b145154304510a21297d12e985df2a81d672da1c1ea554f8cf81fdf950a0ca58bf858ce21ff8bbef9c5947a3bfb7dd428b66972b6c1660bc2824deed10894614a4b33c187fe1a00f3d0185c3c9974bd03ef6049ee370a7eb74c110aa079beaace63b6812c291248dbe3384c078ef5b734ffbbd9408c10124ccdaefd8068b14887359f7463569a6fbc9b61639b59d6162d577a772f0c7d48b9a16a97f95fdc31d24b495cedb04395734348e51b4f8beaa49d29ae7eb73398bdc57bd1d5c00714a5b16e92b1377fb9a982ca1a0dd32fdb3a2679a2f5e781e3c2edd3f5c1c5930567856efa607b57a0a0ccf2b76507b5b2b4faf0d29f7b86eda8b1ee1fb9d07f127ae8c43dc4d36097dfd6889cfb982f86abf1fdacc39ccf51b8fb97c1544947e6e6bb9ea3a1b403edbfc19aff7d6eaf07c45e6b5bea961dd20ab7d2e283be0ba8a51aa7dafa791cf60404e44dd55d88bedf0ded6a18d113823c4c13762440c34ee80204631419c79f6399ede3a013e12fd49d9ee3a8452f864093c0ff41aff7e639bd7519e63d76d0b6d2dc6a167bb0094d2f5188e411ea0f104da81a93081ec0e4916b40c846a7f4fd27aa2efc592371b945aa1a91b3c6062426ab860d7c3013760dabf2a4cdf1b31b706d35b2df5f4febe6322d4bdcbf92b58f29075ac7bc893fb6d3b7ad485beb1e1c24ce2d8619a3e5eee8ca154d5d0ffb88172702d280eaf8fa13e2a4762e938d21e36241176940102b1ebbff1a9117f951ef77c29886962cccd55e6db3c60f7bcd9458c62c4fd6678594e013be59aacf2c5ac646ba1f94834c0bfed729c15cd1937e938e4dc443d68fe9269e6ba371e837f8e17d500f14d9ce141b245e84e3afc458816fed7f6539109c847739298fc5a60173993afef954d0795c71a3ba37a5545f1ddcc7a55ee3a3ffd447b319126c85b1083f9d8f569fc94ed1924a8be0da4c66b24a8727f89c5363bcab96874c19aac0374f42d0fbfe5da35b7d7d5dab545a84380f26172fe972637fe291d2f1ddaccf20f316c51b251215b83d224907333d2b84e68b5cefd50be5f1f346aa64122596033f17445500f9ab81ffd51b5b4c3aaebac386d19425da1ed7ed66281c76fa746123e03518c1fa63e7d3a6854b7f6d15085967ded32f5ce0bef6096d192052d7432b94e8d4e32e97b38bfc047c45481afecbb9d09ef8840d4c450379c609c3bd137df41f90ff608ae3929685466480024c37b9f0244695f52317c17bed2f720675caaf4e05db92528e9ec2d3a974a1a4764a889950f294ab0ea8bbb24d944a3f674863de022597519c99f40b54949921529d8ce9bab7a27c30dcd41532b0ec6b7f2d677578f22ee5b0b65aaf5635d21d30c97900a8a41ad8c8e9e3c73290ce411efcc2be01adf27e5348f75b647c4a5703870b3533bc8e1344f801756a1839833d2c76d82e7874579c321f6601a016e4f5b7ffcad7decc6c1508fee21c5866fbdd05492556ff670f956e5b4afefc2e53d24fd65fce7d27fde27315703a9a394fb7a21584a68a809c318a01d59b2d721014e66c961c61ecbd6e64df8a8f164adfd2a865c49436483cbd694f4047ae43b1c981d1d276a9b1a1c418338dc2138a0a7309ff0c53a08373b7adf0cae5d60089aa0b1c4faf951936ddea2b0d1ddbcba082d6063079d25f28589b43b45fcfff0ca4779ac93b9001c057c2a02f043271f79e4cd0fb3617d1b50745fd60c93b1710cd44dd8879451c8fa7f3544a14fd6698c25c455e855095285fc0485cbd4a9d40e2341b56786dd21da9a7ead9378d3e25885ab2e30bae2af4fd19f5518366fea4763b9193f165664746ea6d644d4aa48e02bf595d9b62945e7056854a36171b2e93fac79e679915ac20cb62b228deee9b9d1af9990e5ac6947d2edc67541ab1c1cf92fe9ca8b119eccca5f2e5e456d69255375f7c932da594e512772bcd62ada9a49f756820d35d43f8d4f1dfefd64448476ff1a0a5aada2b2e17b0ebf6e31fa71b43881f4b1365d024ba5984dd8f0b741bf9492cc755f847287faaf701176c4d652381a02187f749d813ec23f212ba6cf50d72bb24cd30314f0d1a41fc23c49bcd11f8837db6e998bcb91464ea6107ef27fe256b6df50fffb75059d133b9ae7c7f035ff0c87c377a8e2b437efa8f38ef284f79b63db54a3d76b8e696f5ea1ad3d21dfc27b3b01f89123345e8296a9a0663b7e9d6de118eb5a6e69a260148354b3a012b99f40ca39b68146cf4c699c78e52b2c924769821f9359c100c6e81867fa12780c39caf30ec385806b0eea0754c8aa1c39fd83574d53eeef480fce7910b0cdd01495535157acf4c273347562b3f4553135a6ecaed100ff85113d9e0b6b4a7b819a2120b478102563c7410cf9e31a5d5edc222a09df504155b62f57eefab132c402fb163ae868fd2b80e45939bfe5a3ac1a9f43a02752a2eff254033e82e746d32023609a8815982018a26f21bd0253028cf149178db7b6123a97a514444f9b63fab42ee275a887f27ce3863c09565aca79110972667f72fdd951d70dc9f276bae68935070c59b8f300e7745667ceaddef6aa24c8601d90d238df85225d1ae3fd84155e22fd3bbc0d734c704bb8c371bfe8c2c427740910ee396685f56380c080240bce027ecd57f28935464d612c9c4849b03268fe8795705aa27527dc5609ca0f395d76ccbef76c52e1d00a9e75b0cc24fdc841ee9ce8c917d8698a0aa11653f62aae4c427b4b0945e99d6fb7a9eacb9f84bd54c5fba40ab4f6ebb863c2dadc181cbb7b0b7e41e4382d6d129173b61ada32db125d25531280313202b7adc5c40ae36c0cd61208dcb06ceb28b008046e5cf7742db3376271831c3e80448e8ed6b7c0f2797608914b16d302789f2153c54e93058671a3da8adb7ac23377038d8c008fcb0a1744a56249b18dbbdfecb5666da40249d2e3fce59b96118d60ceca923526aab2562b0b6d38b8d793c2055362c6013c97a2b8d73aa66d0887afdc1822686459bf32b8f26700c2e8359a08b8418937d2e74ee9d44c94fe4ebc05547f27c592d9aeaf826b31ace1adcd72f29125431bfe522d1f7333257c6dc651d6cd75fc15f5f0be3d990e17d0a5aeb979d35d56dfea8c029097716b690ad777d95f0ba2e9373ba54c511706109da9732acbb8c0f36787da636ced1ff1f42bf73f05f71840aeeb9c253272655dac083f792edb8a48be1bf496e46629ddb95af36ce9785b2e2c2b438351981cf62d6b7101e8ebf4c178c77afc35c40cfaad6af927d52c84547568ad55cb19fa02e6dc0349036ad48ee3cf1eb44264a5acf2203487b8389cd6a7f2e9127987261a8715d4e57edf60b6782a7f19aac20d77e50df9dc77a1835312bdd7cc9bf872822a19af64bc52446239a599208a087e96a286cf22586a4323056218687e48732cfac88eadb292a9c05782c2a77eb20e2e5826b8e529c65d624eb5566c03ac053a03db078c3c9cce3e013c578ec7ec0f0e7919da024962a8271a16f382b452faa00236e6789701aae56e1d35619848bd18241d983072823711d2f93bbf56e3233531f6641cb3969eabb9e34254f1d78389613a97f190c64005105cc1f51eb4b3101d0cbcc3be16e89da0076583e6681ed0b9a7ccf54fc2fb31ac7b3bb1e80d131582f2ff1bc95216f14016d0f639edb7c1346ab61861d2fba6bf54227d0592b06382f45244dbd30230b622000509c90a8347cebdd3a2185476c23bc34ae25842b722fddd69d99876487e4e759bed7083669756be2b071eb89f7fa7c80c5c16b2dc1f15220f16b8aebd2e615f279435c4740fc36928677a322345a41aad64d789e379f4c1661fa2b604462cb4a3a71fbd06f35bba220b8116e2355d0a6c947f34ae92add407d83b50b47a660a5d4def0e33b2397d7843b6704aaa3ae8f15867f2bf6050e8931d476f4551a9736591c542c38405bc7ad2a069db9e3e37eb6a04286a084249347df0c3f6c1a226e7bfedf590abdebcc6506580dbc0ee67c83d63586e902cf29abc0c778faa97bbc70426b57151b726a0baf5e50a9d288d41e7b074ea496daf73d5db516e3a02fd6472a4516e92be9277cbee9455e271cdb126994d05a4872b07386f3a0480d2c9b4818dfcf883b3e6c39a4de7a5edf3208e8bd70d71ff6547ddcfcfb90e0039d0d25ca919142f4b1918cf2c62c9e7bbe84fa5541fdf02a10899ba192568322fbc3fe5ee84939ac2449b1cee25449460a2eafe7fe4660f61321741002b86138108d8e61901f8564fec3c41fb079e7612c3387b6ae9fb3088466965e6808fe7bc999198958dd942c1784f5ac26cfd3540a5872caebdfea3ec2507014c790ece51692b3bbf60f8446074b377bb86b59326f51baa1b6d75917564b4a0bd459a86bd3e4d7bcc31522b444c5f5ae9eca308cb02718189284dbd479a8468c53ea386ae3ed0b2c480a4023ea2d0e845839599a934d97c5f3d2df073c8cf0061e4ee414803fa0026fdafa6600d043dcfda3ae7de679488e022190384a0a4ee14a44a85eb74d9c82260771dd42287a85a57ff88e377ee407cc0898b1113dbdc302e28a2a4ead5c82a7b2233c1eced71d6c3dc188d86c56eec5f16768195887ff3957ab6d069d290894f430e4ada7c81ffb6d9f268fa1dd4647ed4ce99d5025d19b8a341eaebe1f8396a3752a949dfab474dcd45fd932ea8540dca8e3ae86822b1bbc77e976c806cd136339fc33980566cc1e407a831e6ad619ea46364eb59a7bd66ca7a05ea576b6b455c0206b854b5713e5f4586ca92643a1f0e0c4b36ec36df7d0f6d5aafb801a1e68c4e8ecfdf6f495dd4aa440d10dad18dfbc35f96fc02970793b24690028aad468a4fc75404f3cd9d27e062c2b440320288563ed31ec65f4b6b9e341f820559a6a5440fd74a56c025d4ae2bb367879e2f778836fbaf30368b1df98461dc758f763e00577a8787e36f1f753643bde9ed9c4fc4e8bd6303dbeee458817ec2e327e53357ce164126c3b9efe22a43facc8eb2bf1a129342f973497f2ac66cb4dcf4917e0fe767c8fb9cbd3217becdcaf6783ed30255644d6e5bba4470a92cad811c6cc79785197b5eb10eed38941f26bcb25c17d9b0e8e201054d1b40084e76a028534bd1c67250dcabacdea36a816c3df9742760f26eddb009e1e563ad0b99105ae1cb32ebe437455b50631cdc058488d308ba7abd07acaf7edc90ea02582c4e920e97621c460a327ecb2e83216ee8b556471524cddd4f42553e92bd183787ae5c6402321037630e7a5641ed842414fad40e2c3c21aa5a2eae93e846eecac0f228b93926b3392c96ba3addbcfbee51a9b2a387e362c2541d86c5be810c05a50718dc10e32748d10b23856d869af6ca531dcd1060179e2047b6ca9b793633273ff87b4621cd1ec5ca84a4de873ccfc7371b6a43dd298d6aca6454f8ecd28e994bf9f6a1bee6ec61a5a7e113f8e41be05f00d1f1293fa6e37cbfbbfcb87dba73480668fd989c54778a79918465d342eeadf6f33ad2048aec5f13ff86ad706b56667009087d638c35e31aa83d6fd2815150a627416e024419eb9ebfece5f4c1c63e9eb29fd61f9172d3399f1cbc75338ab236314ba8a0e221edd71216b2c95b077cda832d13c92e72a5c9521d4d61b871d97053a581216a6f4e3e42d29e4000e1336021b54ffccece119cff355c87deff612d0464c3da6f3c6ddca1109ef44d249dde944ce58ccd4870f0c50c281c0fc0b3c817e2eb59a1783ca6900ad1b40b84308f36ad9cfc5012f6390cb191143b793d1d293f70e5b2d08178cc0e1d8e05b2f4924c1ef7102473ee9913f0fba49b1afb8dd650a28c60155a6a103c0b32c3e191e0614155f6082c709b91329eecdbac368dff68f797c9b915a35fd870f54d5eb902325e55a45b705406f8e30471d96d0eb7b7fdb1ed82b4f3f1b7de8db22b75f0a31c3d272eeba6e756af56355a4fbe490ed4fc7a30c96a1c7a7ac1abcfe827ea20110bc6395d7de5d887ff4616d749f115cfed2b827ce624c1488a9648c9b6ff6cd4decdb4ef9053f3786a5cb0613895d29d3bd916de9852a06e69d2737d8020810f450e27c9d8f179b343cb3b9275ca8f69a85a54ffe5bd7d1b99bf057a47461dcea5fed5e95e9eae09850df401dd1eca0786c685838a4c4c7009421568d332bbc81f0c3fc0e918c5847bd7377150d5ebe75fc607e5c08bdcdf81dd5191fb409b9ef725fcd5b469c0d62279cf1b47214fa93c80e69b6115ac8f4128a66cc5e1fc6eee595fee14d31445216e2c6053d7205bd959b9fc30976b8b244b18ea487ddeccac4325680ffe03595e91da8289e4809018d2d89cdb96a3d3c45153b6eff6b43d2a13e3fbd7540b58b6c2692e290e97fa5942c5d8134f6d7afd9867cd221ddecbb1b0e09d4bf9364446b25821ab614cc2e9cc63706cac823d057d8b4ad5b16d4754a639a87fd234e6838a4c65cad55ac1e34d341e98cf2145ac9bf719328dd776eef1497b0c1408375c9e548b4c6c8e9684764934a80a690f12ef5b8722d4934bfd01ab0794f9009c7b0a7680adef7d5e41ef161ece8103bd5a9558028fcced2aa9afb578a9df5cf6448e8ee91450670e04fe19da61b598d0e8455c46a37ea617c0d22eb94ab3c77f355a125b595ef629ba1afaaccced96f282a99eaacee1a1a9a383585ccc28e9f6c80cd52f9b7de91a4d72c9065c6d4fa0031be5f291ce1601f2090162b4ce49518c037af240871e3217328f5d59c8c92dc9dcaf209b292996590248d0d35bc1414ce9ae6c00a891a5a31df7986a06bc896ab257258ca00b8f560e8c4403a1821b931844671ee15fb7264ce63818b884b6a0f8b2fdf00b64e6cd5778a95314b762fc3478c16ac90929915f3fbe57054bd01682578e4bb6f309b35b9190b00917defdeba5cb17ba4c40c0010da9b0e1dea1f571a335e2311de85c937d63ab5b553a6e511","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
