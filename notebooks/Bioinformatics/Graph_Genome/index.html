<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f1880241e36c5cd16ecf9a1589915a7225f43a434c6518f5bf1c35ca5508d3d2e21f828547fc2e58bbdb8bff89eb88a48fcaeebad6efa2c89cb74cc0e0971f433b1d6ee0f87a9432d58dcd7fb062e0b3d8e150792669df99dbdf3d9b627da52122a172535603ff944fa0cbb4e29767d8b2170965a01bf252955d10e4779ae513bd64f5a101dbf26575ee81fab38ca5690b30c44ce2d954b7fef9680296639ce9f803d43d0c291474670f9e0c9bb5466b99b104d70cb637039fc17f19ea7163587fe36112926177e54b15d3ea5d00136ae13521c90fb73ead82ca4ea52a80e7736f4cbb12ac8186c98accda7c1c756463b5c3c7a0a7339388543b121cfba34e354384f353b5005c17074e5beb62f1c305f66b8acdb49155a8709dd29c23a223a107148e40c4cc842d32baf1c3f80fb99947daaf41502568d7f875ee849804aaceedd77647b4c57a89491b6004be1e00d43bb523157f5a3e7741b6e37d6ff550448c462aaa54bcabd87cf7132f0f8d6575ed7b52c6e2c0cddaf7e4efa56999c0ad7cc91b32519e9b776216c36cddb0b6bf813f9db290b2f5fa12f5e317a53f40c078c929ef96eed4788949698ccaa56d7800202a256b30d0555bb6a59e8b060ebc128ceb121e48e92e6aeadc95f814d2f0a53f3743cfe11495c2ea995d678e9a2ce2a77c66539c39265bf83fb6b2d1f5a2cbd20a4b046a3d78a36a432f8b2ff8ca47da61489b2a6c3c4f44f9275e773c8dc1a1fcac0624d0857f98f6eb2d4335658cde833852de1c9230babe85f211f02f6cc92469af2bb1d7416fe6752ef32c7494b17418f0620927f5f7feef4f3c5caf5114cda8d8a0f69fe29f973fc20b49c8fb44b36115ab351ae05a7efd001dccb8912f707a7e972e204871b4416859a4a785044f7c42e0291e5e9f5baa3b6ac550b524b9767df21a081b8c1049fc2f8f2bd620280730d2a417e19dd3c3bd6f6034fdefa03ea03ab3749d8d7671f93de04d28c52a5fb02067f6447da3abd57d112a87d8f0253569e0bf43d1c56672f6d07b7a3fb7b27376d87c1eb397236888de81a56106e788ea3e990ee71f288a680c405493d232926f0a88c58a067eb47c8edb6c9221b835c7f1a12a07328245c97fa07f1e480cbed82c8b79f581fd7294c8cb5660938312b47fa621b6181113020a121f9a295687494ee3f6bc8083286cb8738d9d95add4128bbb261a910cb9eb72a392e323a557f3df307eb291a79cc47173475298fa05d69a33baa6fc2d952133051b6147d0273566bfc41f5094a13c26a9a53883ddafde9fba63c2c057ffb54202d10dd5ae455b3655d36239917f4c95c620206a1cbbdb431fa81e1063663f8f03c0333326878a839c9a157aadb1271ead590bad71e5d9a9ce59374c1bebbd57d9e2b2e99fc0e8162682777114142c3d0b4706337f951d10a5a907b76f154dacb95f40ff6076ff88d7f2b2b353dfb421a0f9cdedb0777344fef5d4e6476cc7b656fc58172d0b8225b5bf2ab117d0491785ba17b5081096f513048427b5747ee66fcd16135dee0ec7a19549d1a67fa867f02705937e85e56d3bd51841bb29af1f8d5f1e1707e22f2c6c4ac9492909d9353d3ee98275a31cef7a57a77c11bf7bdf9dd1a88c3d8f9f3c444f4d2c258ebce29948469a309586cf4ea12b04179e24a58a2cc57a1e51ee28c8656c9f6425032db7b62648d1355470ad470ef3e37b2aca1ef28bb4b4db5b3de2ece8d5566afc30eba87f034ad585d1c7a23116a60044da9aed06916c5c7418d30ceb9e9902c805e41b6b03d4f7ccf717361786fb56a812ddabbc718544dd52adaea7de59de899d4e9544a77b648d343c63b20bae8abd162240a1702d9f864a528f04a09d7c843387d3161463d3a3bd9ea99c279c61c350d5319b64597a0a4552e119b261420ff15fa1f12cb217e60723ac1c5772da93c3fc3b3866c9a9bf52d05021a3279c6c7a42e39b74a38b8899f11de21358ab571ff376ac842ea9dc133b5ae0d900d88a5a069e39c3a0611e77207e6a34803e7d9c20d5ff9563258b43dc6df820f12ca2aa1ab38f3f8c4d7c2bcd9483685c402f78c21af138a05f9a2fd856037367f1279940685f423af694b0beb013b9e59d51473df041b4aac41c5c73a2542a0ef68f5e5b4b07521e8c526949ee6e16cf8e1d2d9ac109a5c3c16ed72b9b020fbbd7610ad711bca6a67b8cd67a0cf03e51c6dad242758f92a248fbfc1ec486fd56370f1c6052dbc8cafcc2d24349376137dcf365ef0ac862d641f530e72cebe888ecc4487f11c85f1fd1ce53a8e6ac7cfd27eef071893e87a719477a2ec785fe3b40f014774424e0131e6c78dc9cae58742e6b116cfd51d2fb06b202c220fc188ba68c650cbcc49dbecde6f17d83ebdb27861055ec5b2946fbea9918e8d13dc053b9f0531dbd43692328f1e39f0b6bf2b74cb7012eb9ed0f290674fad42e281e1a278116ee78b1d27e964326c8b81f99b395cd554f74fc892ae53dbe4103257e15f893012cc951d40cc1b4e9606547a675f66010e2c01cc7159ffe759e61508253c9141c5a36ff3ba5a1f775b4fd5efda8f61581e673580ebf913fa6af77e36f3e42ce02b3260012d42c12db99843c05d47c903a4a265fe65e01c5301bf91291f958f1b1559fd0f4df0d91ab8e1d4c469b1f5cae4fb22c47c1e53d082be3f066a03540c1a39d15a8a06b85e101513879991c69e3a8aa24ee92f49678fe8a78a6ce58d54c9a35d2d42d7c54b57607e71e1b9d760c46e266704a021cdbfc347773c00bec01f30559a4039134de4f2f077894249a6ea23c9afd913e291e5e47e20216ce634371cecfce0bfa0036629c5cb067853fc3e06021aecd533f888fe1930033571170b49b0e77fb12da9e1c46ae47103b71d8eb22483bfc3a5d84bc1a5879e17f2776087dd82cb43593fee9df3be55c45f3ac6af6395d175b0e5c96ec12cc3da7ac57174b979dcfa013accd3bd8e91e4360f7e6194d826561a3ca143020f29659aa8d754f69641165fcb8acf6645af434d12f7601d73018ca2db1a89ec78af730d5dcd11c392a9ef106e378ca6724f969782986994074fd1d2480f6998fe9b4aa9fc73f674084ad2ff0c0434330657f30c05281963fd7b4b5387bd90b740ddd9d1a6e8cc7ea7ee1bcb6386292a8a4edc6fd56b3221a595bfba76acf3c7f35f12b64bd626e2966826b823958403607a44eaf2cab932aaf786e7cbb256fd422d54294628daa180aca046ac5651c55c6dff28211b8423dd95c83a8248f9e3b3b3096f2a9a0b8622b5517dc1f6433c137a9ede4e18926d96101bf07f52b7123054acf018287e3876bfdc9ef1173c3037b918fccb6af6df5ae5df91e20998c817e0de23f4f6c3114dcd68ea5b84e9e0c89884bb19813c4137a9469af7beae88b673de30fa6df4edfc6ece81e2e92c766339ab6a6bdac6b546b9bde92d97ddbb7978eacc810d4c00e1c2dc0a4a73380bcbfa373a9ffbab204de2809680478edf79cb6b48cea7f0c013c697b28d421be99676d83395eb33bd72a3feea57d490837bc3e6435991cdf66d0c57aac59942107a9ec36146994d1d470552ebc2084b9b18bf35b0f062ae446d346b74c102c58e4e57c98f167a24a146f7d4b3961cd038bd5d9ba21b517a970ba83c1111eb7f1044ea78188089c4be0d2f60c5a9647b37a521d090fda8e7fba82cabb2490f892a2d217442b2c7f0c135e28d4fdd386375e6360176a4320489904e9dd3d9f94c666527c57a68636ec03a96630c5ff9484fedebf5a131c78ddf3eccb0469deec16d92c8f9a3a1a884a722084d11e1ea4e57d493b315d6c9526cd08c5898ea3175c4e5453d7b689b046e7ac397d7bb33fbabefd0ed52388917de4a3618ce9726b6f2540d83ba321320ea0850df983dbe2b72030b62cce93c9450933d6786deba39daa5aa6068d79f47ee806dcbadb19ca49d7802770da9a313fa876f21e7967446386da1f777e51311746929cc8a9985b63d0c9e21b41e6e52b2f5a0dbdf64abd3b1594a741d195eb757c5d18fa84ab1d080a4084875186ecafc9b6f54cbf49ca93632258121c9a1720800ef0e71e671d216c97ac0c1f5cd33a75acbc694a63c44e3c6c41eb5bb585c698625df41d2ff4eb992b2a30f150d3a3996083b15a05acf2ea30e3e129796cb142966afadda04d8ea41c6fd7103c73807108223dc11cd4a50ec91ed265293402327d5a8bc6096c31b185acea43790d001b186ff80b282d2ffc45161f7a3bd4f11547f3143e9e7c64eaf53f1a27ad56107d18ac22605241fbcde640ee95ffea5d9c0df7098e6a079e901b9f1da42a836da69cf765adcdb8c5ade937ab968906e6b0e2ea58c9a68ceb64ee1cb6ddb8c3fb8603b2913f720c484ea85c982ffac32e691dfbbc04d4fc715ae018b52c06c1727dcba49e51e01921f32193f5dfc14cef148297cd48da3dad78c1dec0b29950bfb013b19b5b2ca9b1fc26acb8d759b0aefd3cff10e9cf4be241dd9d053e59abb3cc5767b547ffeeda62e2d8fef68e7489a2ebda6d6388ae22b46f2e589ded070bf690cb95981625ac8aa0e1f155c352fb9302093ea4635a4913b9250eca6b5acb2662e9f7162aae327319f22ce9a98ed8ef67646477a77ea567cce224c73f1fff746f60b9118e81379691722f0aa0c4c4245281bf15a320c58988611a7818627920c79f06df9c385fb8e876f4b58244c1749b62449a6050d531c3f2eed5b4fa20829b700390dc2a14a8c34207c134ba9cd9b805e6bf6e8d32d2382f3a408b538b026c4b5c7d6afeb3483e03e05220470d223bee2d48847d48b591ee76ab96f5b21edaeb1daf6b85b641f37b03afe3168640087976b0b641c03d2ee00da944a27cf85d6059282d1aff2349518651d386f630a9734a5f0a8ac6afa08d6e493654fe584281dfcb2ee67046b0f3f38893d56b2c1aa056b72b141ec8fc79e219c3a68e533e7798b6259bd1bf24d84a6ab33e453697f876bb5e48ae63be42c6285cdd445ca80e11fe12a87c81810cc25406adb4738e992856cf39457c3825f8425bd8d7c4cb38af961b875c2ca51d88ac7fc74303927bd2a2977e2a7c79d5cfca70d8fb750ddbe6dab28f99184148d6f95cce1d2f02926fcb118180a07e1b817c0c29b071775f3ae5389f2b92912db12dacfa71699a5d42f3911a0742d66ad0c79f94333db2c5fce02956a43d1cf62c677e3994a63b2f4865602c447c2741f76f29c971fbabb00a9efd9819596f6c1377618f64efd0412c4bc86f602da5fb4d993fdc173ec04a52914355474d2c0af24be197789545ecfa1415b67b518dfbe0ca66d1437940a056dae2b5070ec337b5aac8770c34bbdc0b3702d7e0d875e424ed3f37b795eaddea2e9d56128059d643e7db09440a729d844594b29e22d0e4f83d0569a8d4230fe74a0b172008cf66bdd379cfdc799ee22b8ef537956bb69b93fbcb3eaf0c4bf990f564ae8d686a50570e2ff3ec58612d5d2689d380e57fbea7e7c899d4cdc597f848996358459aef0eb38dea6e1d35b80f3014afd1ff4e828d668946e5645280700a63617a259728e661e13fb87c4ec34678d9a0a7624951a21009f4a793f17d51288435c6c9a82621aa4b0a555e654fde590c06f341dad8fbb593bb5c68046676df10c633a8db63c4af121ed8e568f63820e701a9bad527cb7fcdefa0aad2fa6af107f2edfcff923c27fffc1e7336e8c3a318041a60c0273e85f83a333259011ed49d1255c20d8d8c7c7628f7e5039c7aa9e24b1ace45e3fe7ebcbfcab0dd4f9e0137d072cd88dafae97fd1fdfaa17a62d69b462db3cdd352111e3bdd3d0e999081a1f422dafc6bc82cb9293274083600385eed486d5052f21237eb071bc28b9a70c8d675987bd8e54760f55efe29917dd29490b544c596fc5a3bf598644a4ad6a66041bb9567b856701159b709c0a97f9756e678475b69b6bc0812935c36dd0200622e590ea6d685c19c1dce481c9f6e4bef86b3c43794b1f9e0e928f6cbbdfc9db10388f9d328b3ee6f95a855e957be6fa7bc0927e251d2813c82896522ad7b2ba663dffe941d6d29cb76bc9300eefcf221bb570be1ba5b01206d368ebe58cf4963f0306bf24bb34069f6fc400d03901334d7be6fb12dab3bb527fdb183faab1e821a306034ca0d010b35445fd5349bc23e69c323b47c172da44d28d0bda83fe0d0b26264b20be41563fec7e73038bac06fc268ea946068ae959dba973e755f4574a8e5c762b50ed1ae53586176361df2be7916811b7cf0f82f03964d071f03c22e70adb677a82e6e1a73cff4b5f006e9a0e69d7f5e2b1abff2dbaee6927c242f9fb09aceb3881a5e8ab346d7a20b52cb0652db10b29dce5df54c7442df78fdd7efe93aa65950c391751510abe61874368c1cefb2f26a2d37fddb3a51ed814d9f97f9d7bd90491564c2f0ca27903aa929bab2f9fd9404bb3fa17cebbcca5777a77520aea77546d941e3d447357c9d1379a082b932cd05518a6b168b96a61794ccce2a3d956d7787181563e8163f5970b961c40e2e5eff9169a6dc641ef58dff4e1354fbdfab9c540ecad1841a1049fc12b0eff1afe35eb1c4da0004e3624bce10ab134e176c5d77e53557e9fb56b67fe6d68434149ae425f07988c50dfdf2061281d6eeb2ae4ce8a57f3bb33979ec65271a3f1ca5eb8643704dc5f41efa776a0e2cc2a34e20615edd4b69dbe3d657ffbe65c6e4371a4d2fba56eb9c6fa415d1b66f6efb682135c1e53a00884232f8d419c23af8ff599592703a1326dbc3bdf0551e76581db47f0da9058ffc0d378ec70ed6c40d1cb9eae213f73c3975d790b41bcf66e047bbbd79495cd82ef1a2a4a7e8924ca8afc8dd3b373fd822c02cddea9ddad29f937d9ba2dbb0b55aa224ddbd37032ab5121c3d1f158faac4148a41c07df5652619d2fb329f3849872b78ac97222abc00e364429d3fa0df508c275d9bfe80886eb494fe6767e94d1b25571d09ff8a91ffd8f515dc1511ed24098ab69e02966ed7fabc81d38a212bd11735a9a0c29f3dc28fab89c825e576252736e90166de831ee6b9f467aaabb8ae982f8ba2c2b785b207a84ea5d253644cb5b1b082001e0aeeb0190b278fc0d1e4483282cb452d1ac46b6853b1aecf8908d4cec242d3d0248d90f3e47fd593d80108a02a21a9c2a92ad2a60f7ec084475905f3f2246fce603d27564694b991a4f09682fe66d3bc39f6c0f284dcc29d0d2956ec9944183a3cddb37edf539f7971de5c79f1bc7baee8ba2da1ab54583bb287c147f98f9bc3912fafed85182dfdb83730f1761224ced7e1c290d179ac519f918565dad76f4a7f67c87318a6ef2b659e051a4de824211dddaed2ced02de6c61b9f5e7d1c51ebd09c8aa1c595051b9c0aba02a0705b1ed756a3b70f7d320d0dce31c2eebeda43c038bdfc4b62c5f303207ff40fa49957a380ec45d268c4c41d27a1aca03f8d4b04c739eceeb9216067595382e9c68d0b4fa6f8ed642c59597c38a35dc5de738ae4c25f43cb22b703c254ea2f8442bf9d748725ef8e153cd3fac7a32578fec41cd465fed75e9c263ceb9b1d363e7df4de979aa69770584556ce98f5f707df52c9910514e6fc41d84d83a047157004c03f2beb88224ff126bf62d2dc51e84c15888b83f818356e631274f3298e5e0096bdfc5cca8dc9ef948585e59aab8a4555c4f5bb984c8c2bac3a876a1d3381929518d1d924ef2a99f296b9d92f328815e4480326aa728ed7f6e3a61f4b4393d97e3d91a857d64ea62a7a9efe074e44cb818b7da38ad2275abf7625214f9f28dd3291193610870a4cca6c6e68c665f50f8f4a766a3002fc9e68d1d298f4cb617f7fcfac6c82006531bc92e3a279e327992e4f5d961c834fe36dda90dbae68f5eb4e72a6c57b66fa46aa687e93aecbe62ffdae2eaae42a9e1869bfecf66852e90383bea7909173aab5efed4158ee3b27777f1d87cc36400acac560bea829806fb2b5ce0ae08ca9f2ba3f4863500728721b21d4381df0bc3e4e6aa9c1f06e74215797b15e8ffedecc3ccc1c6d87a4babbe33707f1ba4a64c06e659ce6ea26b1dda1d78d8746142e0820d6813443d84f9d8d0a2ac409c1fac5fa7215711b2b1e1d7961ad2cf1693e80129d0b0c02d6a2f7121ee1c304c52aa10156a0da76eabf7643f20c6d569d286577e215c82947a5248e0ea2c767355973e0569fc388f770c0aac6d043d580c918a85a454f342a0e78504c6676dd9192b2459eebff422606eedc63d4c26949283b0e4d9e23a32ea435da8168cd616b53644024d6e578a00c901a19238d7ee9fc2b35ddefcf0ce81e124829ea52df09c364ea123cdd6c544ef900d722a7f1d4bfb41125cfef948b70f24446b7488136014cec0af651853bbb01e5748229f83377abe9bb8148317ee8ec761f963dfc7575bf3bd4615af42c580330f3801956a3201fa6f17347d0973cc53734789a823732e0ef03e1d5c60bc7b00ca5230722b0d22bae23728065e79664ac6486a11486ecd216041a1d70986c39f901116d534135474cad77c544dc91ec60fc7ac6ebb446304078d023bb1ae677d287e3e1b205534b1ff2e9130104fea6d1af1a5ba093dcb7c85206ce133aa5530f335b063f25fe3eee70cb2a0f8c7e9813a5a68f70f16f8e351b7f2af31c8ce686cdbbbb8abced69f4c5db922febc42271364cbc043556ac029486d0c2ee87f337b2ae1bcc3846579f43d3a8f43bc70c4b1d086e1dcfea02a4b7be0fd836e8a6d45018aae12ee25f586b8f0e73147d8a7e84225eea55feb7fade64099daa52aa770c23ca7f1a0abfdb3f01b083e90043b623b23e7c5a0159bdad9913e826786262fd13f0e26d0322dfde9fde658ced3ee6d5589973ce6d67ae3e2f124ad74dc23fe8bc1122a6accece64dbf2b95583060a373dd219fe8302a955adaf76b8f3140586c0b05a023daab93486a587979ff3ae8e9c4a0f13583b9a6c2c3653dcf49caf4ce287d139e2583662cf447a6b2fadadfbf1b47ef0321465786395bde9f342313907e441766f022b0ff6cbb92616837124a341700903d02e87d9917380a7eaa70c3c5a79500e59aa3f73cb7b42279094fb3de1ad099351235855213d71838e1094eab5dfd2c346fa09b69d4beb02f89466ddfd57c99cdc562d1da9ad2754908faa1bc08fe34b05c3de316315e53893382a7bfe51e3a76c72b7466a6556a8bb75107c4cd114ddf0b575789e0a0b89fe6a36f9f05f04241ab9ca95c1cf99719dfd812d7d28738735500904c7ba3372ee816ad689e3ed7cd1c9d2acd2d30061842eaba2c757c7a14fead2c6cb5918988a6eaff4fcabfd43ef2d486604bb074e59db19fde08a15d75da688dcd6f3f5537bf32b8241d2cfc97635d590edf2139f0695de2ae22f9d34b142daa0ed3f7b2a1017abcd227dd447cb5bbfce04d3e00a2423f5f2c443539d1e6d407512b38669fa461cadaceeacb82b711871566c095044a37602b3a5f13d73e2afbc0d6530c617c46e576dbdab9a3afec8f33dfad2d1dd64724dd0248e83535bee8e674db94aa32b888c247c03cfae1dcbcb22246e2ec3667ee2457d84cb27b12729bc47d95d7af301f385328b879a5cb06d413b8c724d801e6c88837d1d7109b86a912c988217a93d0092089a76c0c32e290df0a52c9af6c315724006940951ee45fdf31589fad6b3a89c43c76738f63f69e9d1b9f092a91732d716256a19f919778b199d9e175ff9bc5ee0001a0119473205e5c23392a0d55d9d8b1c96ad838cb2c88d9da6e40e0e3e82b83b2de4a3a027d84c7fc8ca976322ff0128e53e5aedfccc14dc4a415d546ea92e37f4adbc666fcba519809730234e5ff5c541e49cc46fb25feda14c3b025483bf3515463293bc7442d9c0de9dd72e7d3da28f019db8f315a96f4706ebddcc7a7e63e02b74146e2db12f29bce9a49888816d07887d351834bfeadf8d89a8e42cdbb57616739ed17033add770a81c93cca0d0b6a18cf3f6991f997a5057b157fe975c9ee4492140b8bd57cd5f7e6ca3796227a6bc72e862b90b9d6f0fe7290e45262fe22f6e2adc519f160c77dd9d41e1f46d7eab1929b373eb7cb582e7eec1ff71494be61495899c484304a50b56676fc736530e971f02549a6ee47a19076a368154e4882966b26a2765f8148637a89e0cc2736394b532a559f9c477915340eb94c54d725045a3ff5ea85befe03e364dd95a65ab51c0d5ec1f4bde63ce37c318bef884a810a7798a6b391c099ee38f2803c4a2648b7c5bf6ac82a490e516b4d02872767459e61955e6c11b226b90f16d339faae56fbe85cd5ad6f21f5e3bab60d410a9a200ddff3a50ce7a77d152184585ee7607558e0844f65fd7b1bbcc17a26799e577e605328ed9025bdc9f15642c1b8a07fc0803c34d1a72cea8e041c03e0c70fa7db2c88a111cc46ff4b5e8edc1cb0ca81c856573fa2bc6d6fdae1a7c7807ff03827ff680e6ccdace6b7a6d4123f2efa4f0e95af4620b12d03056a3e3c7b03817cffbebc9c745a6cd8bd25f7c33958f503aa407e293ce110de8e93d8f5bbdb1baca42075cbf0b8bf9c253b4c7e70d2190b5fd5e598458f20551d55df0590047624fa9163f16c5150fbba481499b51000c87ba8954df4751fe5c500377c692ab330c6608e6e39970160f6831b8af5f3ca148666e124ef16c94b62bd0db1c30aec89a3908c25bb5fa5549621f5ad44eb0069dbed36c82b7d6ad3af7d2da71f9d7bfe85cbebe5dc7a9fc1b2437a68627f7f2fac188d61d7f2075d0502da369a9e789cb7e2c6633fdbe7d623577c722920afda97e0a6da8575b81d900e24f3e15b2f27f70ebf7131f6763890c3f611278fc427d55d07b79eedd604d4468832de5b9b55c97233bb92559c1014f80fa6495ac042e81b31aae11e50a66e05dd6c137343824a2daef6125a635896bc3a032fe4f2fa2e3577d5611390c1cf5562df658b87b8d7ec856a8bfdd9c2e29f8a574e9069145ec971fa90d20184e560bb1bc155ef608501baf15c737518f089a55d3ca9280d4da41bda082ebad91fcdcbe37c8e2bdcddf06023d55547d44ea8b159313f2e2c02976aa3acc650b89be53e08fc4c4437669aff8ad9d23191606488df7b9d7241f74da8682bee053d91adbfadec7ad4d0ed2953a61448a6ef6d61d80fe9133fc083952a106b06b49d5e055f72dda5e781ccba8a1fa23b7f0e186bb2f45bc7268cb80382504a73c5033ead37c94187eef94adfbf66da52016e9ad9a4af0be798ba71ef140df56e161ae92161262f0938789c5e17fe5ae327c0a9c256d44082fb8f28dd12e5b4065ad1948bcd8925bf58fa0690a5e260a2cdabba3e1ec994bc5bde8346f9e0e2190e3aa37924aa915946b6884032a0d2c27f307b70855dcf0fa7539b8a43b6e2b22ee49f3c7d4fe0d573331bc5fa46d39901dfe7475d8d7c0941b4a6143c695500cfd37bafefd423bb0c3f6387a4df14f424651f1e1c63ae71302a16dd4acbc9d291ac2d9442dc28fa22f0a20a7c7058ffd072e0d72d75432331099cd95d7692ef45b27d9d21a5526ada3b86da03e9a30dbe1faa6142482e45c9c962928d50717acf343d5f0a1a26873e6c4873245a500b3209cb7b9c629e014b85930b237ef96bfebea9d8e5dafce3c75cac999b6e46cd481a164495a24314cccf139b55f300c2513de5af541c6a972ea0e46ac9787af791f76cadb1f44544edd6db9ca2ab70b63418a6bcc9db2a1d8e79ac11ba24116c5753b1cb2190bfb45ebbedcef2d234daa51d6560354a5df0dcd4eebacc97dad197782b95041f2448a02492fd78f7935b37b24204bcc76aa085fff803e456cf1a914a0068fb1868624e63005466ade21aa3cbb3b026c201f834c4c002e7e4824819bda1194b6c1b031b478d25747bcb105b5fd96133f04511ce15c5ece25d2332422f298f80a9f4d17e4faf915f8526433a2b8e7bbff9dd204731b59d235f36e5a98aa752111b7eba17d635df46ba4348f586560967b7b155fa62f4ed28b0bdea7f3e0d23744308d8b73531809f827dce018d91ddde5ffff1d3e204ddcc616e2cc1607fee111703b5ebf8d58a7ae4ef0ce7bb1b1a13a4d5e8ca977ec4edb0832690f42b13f439adadea67ccd94d098f51757ddb07640a1102c10db42d06f36c9e2cda2b20865e489dfa9d1bc6b6803d7364716cc3845d95eef9e595409ef5d9240b7da464d60db22c5a1e9039b0393e65a452f2c8f74877e655753d4890e774c74f44e5c23b846ba61b5209e1f0fead6e87b5ed298d33033436b21339c2920f55e9d1c10f88b7f7cc183ea4b13304c91492e341bc0dd47da6b6caae2c0c736318cd2c21cb1ff7360ffb96711967922a423d075403fb085d32eeeba6adceff223df68bd7aab0080bb4b44c9854d87819bd0e540bc54243368f9c36eaa9c90107f048920e5cb0b4389b5bfe59d226651a2fe6fc73972bfca10206ecaa424ca6048aab35a3c44f1207b64c87d381fd0762e00d95f1fac7887b0d4e0a3c7dfc7add3a632589bf3df07647b83d16a89ac1fce007fe60b6ad79e59f4c1e30606e72e96672e0c4ef5b1053afb4d7993ee8dac52cde0bf36d4573ca54467389cdd575148b7fa73ce7c6b7ee9eca10abaeb770bf83e5e1d3d8b9169a31432f6d8e7da0d41df514b05f4d63e58790f18de43c423e29ae070d732909474c7cfe6fb469f93ef321ffe0802f69f60f2ea8a3c54d80f6ae5ac99919b7a5bb4f412d1c5c70cb8373e8c5e31a11bad07a86e71e00e0cc11edf220fdbabfbba2b6b4c2a9a7120c01b2e2132caed5a7a39837ac3dab38f131462982775ade45d8991b3536867e63392102c9822f5c5ba32087dec9bc3c6c543cf9aebc49e59c2f6dc6c8a8963aefd235be05506769c7f1bcf79933307acf08065446087d8556e046018744cae03025be8855be169bf61f1d12a20dd8cd388fee37938eb59c093cc9765965101cf0361cf139829bfd131fe6032c4f407e9eb7b6d97acb28338e9d8e5632e32cb57b40371ca44af06d77c8571c48c36faf8258a17c2012ef0aefef8a9903d8582b1176698c29a5fa778ce009bef79f491295421345bda32c0dfedce2cb4a99841e8585e5d7f8abdde73fc41c735aabe3b18c7071149c57868d83d39f8378937b56d6889ae36e55761e8f3cd5b16bcd85c68d88d56ad3d6dab8c1b7d1bda74dfb81597464facc3e50bc55d258cc7d6984210c4105cc4977ad6814361128136b174effed3559891f4671e084f58b420c8d8e530aaf56ede5cf1697888fe37134ce1cba11771bbb73ae797d524f4289ffdb2728437f3c7c72ae9e26027f574ec4bca38e8928051ab0d077b899b6a91c4423166705a4b3817076e9aa7f82eeea49798d7462b14430234c7d224d9b9a0660422644888d988df5ef032128944835c8f36493b174454f790e0ac59c151c9e6c46eb1c5a167b961abf6194c0fbe1c5d7837cea959ce46d70f9deb1c79426ece41b53e1c68bd200bc64f9ef0fbb9d412e1deda50f0e72f830f7eb5e7d47ed8efbdd21f01db610f8e8c0b18269a8e900c4ed32ff59c77cee1acb1f87ba0ec38f5dff4a1afeef27d0a09a432b886c908fc600625a7d54f517c648899364e2dcd0fcce1c1d7ca1ae6af4d319c4b4a8d1bd2431d15cf62980d7b6c3eb231198337c92f18529c0536aa1ac61feb9c87d922def994ddc3f2c03e7f76f0f91c4b5d93be634484acf0daf8a0ef1fcb7b00bf471a349fe182955ea39cc2b9d90579fdbfc3eb8b3a0ba051a5a31c8c46dacb4387bed6011ccaf2952f6316c3f27dbe330927dfa5a93c0190f9db3223c83c756e2da7dc4260d7a4c76d4618fd465ae420bae90edcf63cc5c66ca74c489776eff76c37b86eb8d920c9b99a3e467f40b8583ccd82fa2f86c1df5c2e450d28dc4073cba973cc49b3d02f2bb178ef6c62724322cdb40236f2e0a7089ac91a3574bdc6848fad2e53e44f397acc8f2ed6f296689a972200b465cb438463434f700fd3d648b44d625174696c934a4c0a3e6c4fc3b8c4e7d03db4aad0042be94c7e7975ffe10efe2f7ffb8b661be3fb7560d52949a51e2edd4cdafde02f3419a17650ffc2eeaa8a6ee321265e5caf653b48c8aecba185b61035b022466498e608501a0189c62bad488497e3168b4840884c8d96ae88d675092fe8863f4e55a075b636ba324824f65bc7c7b5c5c800d3d78a76e621273c18b5e118e5341bea3fcb3056af464cabd5a5b94b9e08d9e37589ccf47aecd663dffc47fcea6c3358759353866dd0f3268c92c16892c2f3371c857a7fa4d064f8c7de3b1deb3595373a82e92ae7b097699bab961b642fb6fdf710b4a46eefdd782b9b2a1abff6d373f48e8ae41053dbbeb58b708f5b951513317dcf6fdef7244fa670f499470c6f0b89a353438b9d6bbf61685df8b213e69f143085976263d0829e0fdd62e1756228ad43525b88829d5ab0140d2671af8208dc9e0a479b23090583ac65a0382d2e1086309f8fb89d0299a1908af52d3a689c8f3f22eec69d2de8052d302193a9190ddbf9109fcb0a3340412bd708e97e008aefacaa64ae47cb1b272806dccbf021929b3ee1bfa17e50a6b4d45ff917eba7e7f81fe37cbad35a68b1c7a224e5f79719b47cd5c5af2e137190ce812007f4a16db9f409325e7c3297929b36d6f9390052c3b68d91d66d17aed9c87860aa903fd6b73f18feb1e5695c6728fd13809858855e3ef30c1b60682b4f2b14ce11c2197d91031cbfd4751bcabb485e17fd6b9427e4deb10d6ba971d7f0aae65e7579758db8cc35264848e3cc924f0b879d08c5e09f5e11d25f62a2cc6b5b71dd770f51a1199d048650e7069d5791828ccc3afcdcc84e7606b7633cc49ffbd4be0d47896635360df690d15730598fb3218e1be8200766bcfeae021193e8d8583440562114da9d629158a4837fac4a1b7400974d0be0b0d1cf0406bd1ad8216ed6faa6e880cc9ffa23b7f6d6edaa09d4d37c62937518055a85ab8e4305e9a6673ede4c811713d821da3a39d841623b1b60db334ed3459a8089b134d6e7b482874aec00b5d4a19f1be85a8d6ce99d53ef1563e5a0684a7f229d78d49e8f3876fe5eed2b79e50b903dfa7144eaffeb6ac9acf56c12784721b812ee55bbf65936aa0d5cc1d8e08f84aab7d6e85e5561e9fcf90771f983cd295d4ca20914b45f46051e2865abf9de4b768998bad83ef6723bc6fdc17ef74cf3fbb8b6469e9a6a4c7472409b4b4d057dc6cc293a82b791f51c95a5451be7d24a4e51ca4e9547960b57ca174807bae9136795fe41ef70568fb0887d62d6610eeec1e6431e641be13c4d33de8c3b83ed1707479b0c7e4d2bd10a7fe720a04f966dafbc600cda5cc69f43b9a4176894530d3ef3e9b51b669a4eb7146d99949660d8b63cbd43958c5e27cfbb1ba962c21ba5df3a8012a4a3b1211c84d62d323d7fff6b500593cc0ccee5d818d1f618dfdd33af4d620492256d05a70596343303629edbd9786d8648fec32322e4d588c15c8e3f36d1fa55532cd6a7f698403e788d79f81879e2731e7b6df75c77191abd77edc8aa4a6014868bfcd843123863f9608b23402dfe1d859b35baded206300c8da2ec24c92d519da5489459ff00f0866628df3e719f9776813c36905d921a86c151bbbd96d5dc3271e7f7d15dec60315647c42d28145c428b1f9deb7e8d4f6a02f925977bb5a934abbe257c6a325150f3f9ce93afd1d56f23b35e0ce6394fda3f7c696f60e602b5be58c7bb16a9e3938426ce2b4153577762e2cf4cfa071bbdac64f952fa5ebcc63f60025390950e332f78113a43119c7b5fe66394419776eadfae46bb3c6a2b3c59140a3680b981032bc0406d59e9b91e834a242182d3bb25b985113501827e2ba1ca824b1d32430aef5892af684d63ecf8df630cb76bf0803cb76515b4b4bbeeb57adb97fdec042d5dd8b35c253a12de2031c30440240bb089cce7126782a95f41ea491b8e86661f1adefa2b1316d0c2404a404a526f6db752cfb29aea5e1cf806a22dc62c19ca1c63183b656c753527ae829200d532b826ceca4c994371a28ca2c7fa42358a21f35e06b671dc42d3a0b69b07abdc591247019de1d8f3316feebc1e50bd3a10a0b80e2bc5372d961a3c70764cd473258960060701edfd1b97365bc76adf16abf8b91ead3d4b7024e1041748704443649fec5294d1056739700637a9aa6f1bcb0a37633b04d1721a590f205f462d873c347e603414765f4d792140cc3ccfab4fc86cadabcc00bd7389a3f4024aa5fccf1e6efa225f4b2e9585707b73a4188e52bb75793f9938799bb8c5d0e3777db3ed88798ed1b73dc826c1079b6e75442195fa94393a827fd741156c632cc7ce88746eedb7a43c28a53084360f1e55a7e9afed29635f00929c47d89e133691e7ce1b11d76ad92a9ee663b49a4e2e9f39437118bbf37e9ffacbcfa353ae81bf26f40dd1df4f27528b71327aab4dc2e4e55023d4506ca0964f9cb9d41c7ef1d75478aea88f69b246fe63ec2b8e67f8a12e992bc087cd368bfeddad33839ad59b5b38deebd63de41996e415089e2375dbb4b2cb671bb4979dd2e09069054dee7a67988986e274d8c93d8d46a52663c76a41a3a11be1d7d577844efbbb98f77cfc66ce08ac93c140edde1faa3fdee31a5453c712b8d51503e85deae8e6e77085c94e9cc83c7aa16d72b02d9a5e6ab434f1c6fc6451379b68e09bff4e04091138b12d7f44394406fc7e5eee4814d2a6529b9d5a04a155f062c60aec7a5472a2092e8e501130895d687187682792dd40d3726e7467b6a2bcecf7c8148a7f96db5b0cc915635b625c71d1101b1387302d28e151ce8e16355cbd01a42e333f9678176f9476567806b755671389cd2ded5ac7f75de13f5bba750e604691bd56f33f9c09d39805af2e2b9dacb01d20badfb2596a0f90717e0c5a89f100e04b44bca719fda3c899cf3ab126baa98459f48bf2728e807cc2ef08ed95b2c7d8c68a22f3a779b7f90a08a9e75d899b9a03e6ba35d368f865fc4b188a44199b874e5ebed60b5323cae536892e64e859cb952ed29659fad5493ec8f2d71f77795316915214a00c3d324444bd3767346b2409eb34f03d1045e0d87f99ac1986cf43359644f73037c0f1968b7a7eba0f33d659e0e147b3fe31a49ceea4d12597badb277e30dc11c4017057168ffb0b728d9bf3df4e58b65f3699c67cd31b75d6f67ff443927eab0f708f97da691de43f5a1f2f82f07ed5a5dc0a969549506e906be4ddc285c6a2b57226b6f9cb51a206a860231f321d70cbdaedbdc716004f76f4d205d68b7e9bf04a8fcb3f839a731443a5334f12644951ba22b0fbb9a7cc993f8d4fdabb02549b2dd9a3448a5ed5f2a7290ff3a9be52e21fc71174c632b0433fc27261bcfe6d036cbe7391e28266dc653c95fc9f3e76b7ae565265fa6b2c09807edfee3790b98e7173aa5de4e8ad6001c060f5e2048ba27c2bc57741a78aef9bbc92957d702e34f61f75facef05aca5117470938d5a5be53e14b3fb6aad585032920eba0863406e7f5be2fa9df836c6a7ceb848aa42ac613ff83f3dd4b6b4f0f03b9041a36c0aa57b818d26f8a8b58b6e4c8ec3cbba4a4d57a187e0943afa2ecd1d0e6857429a6344da59f2ff261dca784ee3f077766ba3632e9d01cb403adf78fe29ab4aed1733ad69eb7a462babfa16cd22a5b4c74c6d0324b14d0fe64d4d27b9190ab312b3fbe29b89a8e1183b4da29620790ace67fe9ccadee19ee3904f7be547fd569ee0c88b14da4ba18b2cff94c2bacb1a0f5ac7135fe50714550b2bcb517a3474ce40555c22e5943831988fd958705ed5ae1f1f0729273f634c288463a62ee67e3fe34c511185d7de1abddb5e24773d81629b10b2c664388bf12d3b5e1d0f60c802274edf46d49f5ab5c3bcad7e0f8cb418d0d04aa70dc5fad1715734dc3d4b017b422e74c7e87c0ce437d94dbd317a27de89da3a17948fb348e417a6015f2841701d7b6413104740c13547c8a79856b0897946a0c1b40fbe199bc83e721fbcc68af85bf26305a0e47ae5510b09b034d6500095ada25a42227179ba3a35d17b712cc7f4c78c5677929cc91c2a9ff529d4663d900b7046f527772110d72db5e613e2b40943461aaaf7c839572929683fe6790e9dafbc65653cdf754bf077db40366f081fe9b90ddc4b031d89ba918a4e7fdf776c61e27127856442ae028d0e662c6793cab87213b9b6e1511f79d8743ad4c821175593315c156bec37f4db2a66706f1e3cf0c0cd4ac57cf6c2bf1b9a26a8518ddfead6472d9147ef7da5dcd64963ccee77a427e3c799d9566c5a01a2393820c5bae9101568ee8af30db275b82845c4bcf150666488e02137b60a5395893fc6fb425b7e6070ecf20c91a88b0001e35cc24897c0037e1923ee82b58e57d0fc398cfc3","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
