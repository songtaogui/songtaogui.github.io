<!-- control the crypted page style -->
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Show me what you got</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/assets/favicon-bright.svg">
        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #81B8F7;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #81B8F7;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #DAEFF8;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Show me what you got</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me (30 days)
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"47914d1941a1b15d474b24e3e8c0138c5b38f3fcf15aa10f605e846073ceae6a65706f90e0b3b302d93194f69722a1e695de9d9b7e8c1d4c1c1c1a842c8302a239015d11019a66e9261e14a470c9d761ef7ac2b8b2e0810654ae08cd805993f24363733470d3a909f8acd679907fb003ae6d8f6199ac29d735cdc3eb0167671dac6d7910a29910c406f675609a404901e5dfe8210403d4ec4e5b21c09b7296f3e1c7d55424ebd5a6f03b0bdf3a63987c8c3facfb58bf26c724069c0eb7cd7acfee16298057c96a4df9decd9cd53e0d75e53a72e43f73cf8568ba80b96cc6fcc6fa898cff51afd4551db17a297615ae010f7e97e2520276363d0f7d9ff8510116f0c738f79fddffaa67758cec7de802f2c6c5f53524d338cc3f85a08f5ac3289fe312be1743c9e81ed1daa2b8f36cf8da386dc92a3cd09c8c0300c3ac635b66fede9f5b3106fd2ade09405f49032ad15eab293561e681515f65309bcdf92fe3787c714bd3b0dc759d121786dfc4cc943a1e015f00b85e02470d393336afe0c55343b11f550d578616b6a44fdcc975afce89f7893a415417aa532ea5ac4189ed34bf157a68f982d0581a833903acc93b6232f36d613bc4d0fa7e9c48f1af15b430f73f554661795f76ebfe43d1491d5b7752bf685bcd13d634a13af8545c53f550db97f71b4ecc94c3bcfbc2b792a2782bd7bb9f292bbf5d1cc9ff66ba4038f9455fd5b97c280fe4cd0a9f132e3e930b3edcb7e2889c7bdde8dc171a3fd28bbc7063b045121c6d56d079dd32b640a0ec878e31a4caa69367eaa57148e18798a2d348b4c98bd4d5a3fcc238968167f008e7b49f1ca09a112391704241279919c6590d22c96975d071b6a75732e2e92952bb2f2b1667133b2aa1130eaae0a86c67de2e5dc9ec9a5bd7047aafe92ebcd6e16b131f28d64f8a37aad14a9cfd0d238f242cebf7b37657c6ce1bc1da7450219f0b6ceea60b55a6a4074baf3b44160a27a2cedd756a42f68b8b8c4612cd0492601ef0ed1aad0733a9fb6eed68ac92e7261dfd4a26100b3317d64e9693cfee5de141120fde186f0ca3f5a062e598741a0a7aca09b6ea913eb08d41237af2b273efce7b7f06771fcf83024c2b1c4e7b40a58d64dcdfc7ef16851af35eab31e26890e67459745ee7b8138069356649876ad03214eec7245eaf65dfd74516514076efe3890e2acb513e03835661266b0ccfabd3fb1336f2d3f440ec55cc72e9d2b98b4e4285f5768bf66a1d3bfd44a5a685cbf61210bc1416ec9364ca8f11f6303098da0e784dab2ca6233467668232c714436503ed3e358646cfe608e4b715b1b2f9a359bf9a076b5d383c01283b47c3aa218dd78af39797c336e4ad77bd8819f4807567f5ad7e5f0817cdd46425c52bb9b61ddeb5ff0d09cc6b5752c6d54e8bbeb4024109bf1b4a304068708259df036fb5ab2c8843e996100d47a1655514a57cedeab33c825e83520dbef6ba63afc95b49bd42de4b7729ea84ef908f1ad3952075fca44c563a01654107c35287a1d7bd3449c2ecf888ff755aa11afed32178c156ccc16f3c0e3ddbddde2d7a9b3ce804d713a266d3acf2f6c8d1203c75be46fa4204b5b43a7ab1502d3c4b8fcba2771793403633f3f89aea8c7914f7650e17db0daff7382bf37a25704345bdbcab555eb7c71a4286e5fd2045ae0f825cb85e2518844586542d9b4c156a667d9d0b73f982a95ca5cdac24f0a8383f231041cd226806e87c36edae7fbca59ec47d10e5cbd9abb3ec8aca57cc6ad7cc21eb7c5543329caf41200de9651b9f1864675d4c586b0d43e4d331f2f98f123fa3b1bee5381d6a6c04a26aeb0b5bc64db463db399e65f8294c0fc6f7d677f9e561d478fa0d8606defdab029d4680fd6f3ea15e3fdd2bcde4a1a96ac2139427e319fc20f9d124014888191481437914f953d33e9d7fbe39ee54d8d2084c9d9125bcdd5a4e2ff846492b71e35d88b1c307c080c07eeca740883f03c50d17b55dc2118caf1a0e4e33108f81a37ccfe65b6518bd24f3cbc704013ee4a14326739547f73adb139fda4092c31745d3e4ff9d4f928af22c39198d452798124b4c44d5a4d56e092954eb5902016d52d31f044a1444eb5df8349afd125d10670421bc84198bf6ed16388d5b0faf833eeafb790297adabc16fa132d3f7daa291e03fa7452c4f2509bb8e7714990925a0b194c5e88ee9ac2fee7492ac512bad3f8770df74c594a29b6ca671963ba68cd6cd56e71f48cca1dc586f569a925bd2556ef4827dfc6e88e22a105bd0abf219e4bb5cf52da28819f96b26a2a57e65ae31d3b484cef9c8e55d1732cea26afb60253bc52fbf01c803b455f4bcecae3ff3f47b0065b293a6dcafdb078bbb8392d953a8041b375097928468a32894b2d035119fd951e1e1f9c7311be5ee70e12fa832169f01b0d480b463b7039e334afce254e2357d095441363f221722dc14d9b46e4c532e9f6f841633c4e6f4817a0a87cdf809d7e81e482ddd5043e99f72a9208217ef762c260719e78f178d4d50a3ead5fd6356307663667a73e571a46560c38fde3eeb47d3b8e829f5582084b180184fde27bd35c9e970b219337c79433d04b168e5f51c9fd59e840315309df1f41fdb7dc10724468b921bc1698fda7675cdcb1c73f56260706ace0ab5d63033daf7711edf5f540027c19b543785ef334290101b1f1c6ff138f0d0e4df98405c3f70ff8655638ef4699e18740a931b4ca8889ee71bac9fa847d52c4ae63c07176e2a77a8c2b9acef9c0722fd0aceef83394f0d9620db8465af2a2d34e3482d49a3d108dcee577231ebb6a8d219f9b6e96743ce82f126341afad0e3422166de07994aa4d717270050b3431f833adeb36cf48de244cc5de3e04c92dc617ba449dcf4d3cf35ba257c931e31e3682b2d0e0fe4225848a74e66323797a00380a53b2232756d3984df5287b9242ad5ce72271a8ff1d51539df700b4f2afd72f7c46a5eb0115ca0b19d64691f9b936df990e03f4b0bef90e899919fdc0cb824fecf0bfd025d6b3c2966d5bcec6a411a531881f0c6049690979209d71692109f6b3a9c5000370269b2bda2c0c02fb395b3ccf7715cfef39372259e39ece4a29384178db8c8e7913cf3f3c2879afc4443cc191ac9d023d3e22efc2f28a3e0ece154440c6a1fa59e4e1f62da6e145e639e2da61a00a41c762fe09425de19f6c5e21ba17565535ea70423682d5b035a2c87a4be175a3ba31133981602d667fb5303b2006ed784faccf7d9b6972dc4e9a165d4b7bd1aa289d51ad222422d6793fb9743629a7f9352f3cbf480e83724c28e6d8c07161468d0e90d69a240d2d873770fee7a5df2654cec665c9e8ec0e54f0030a1e8f895f8056f4dc3b161459c8eb733c7cf872fde94bd23909d8074c615b73b4f05a063a84d28afe15041d818b0c44de0933ca7826e27beed891293e7818105497ca66d6556a3b30971efc6e9436a368fe230384efb93e979d23f3ee17000ead0b0186bf64656f5e47e4a210eb4a168dc047864b468a902f8984900efdfe6be46acf5ac0f3a5055c3c829548ff2384a7d614d4482e506ffcdaa837a5fb8346afaac9c692154340d5ee90c32c901170806d217f81fc14117ec14e40837567698cdf9788ab4d0c64c0fcb317820ca21475caf82f86e62e48b4f2fc744b4468216788a00da2bb80cfa2d20850537716b3fba68848c7cab6fc9c34545ae773631490d6a6fb7934fe1d4610800dfeaa57734d6f61fed0d9a26c017c791352aa266195561d2916a9d2d33b8bd7fecb828c7dc5a945bbd1a1c8cd1e5e4de919a6db5f1b7cbd89d9bacb12d80fd19fb03d6d11407fc72c33f26fc73e9c49d491529733f540e568a581fa3d24687bf612d3bc61551698b5d2335aaa0c2b35eecc530641a8a8cb251b51a73d59e61a1a30588d9f90d4652ca2486782ca3bb25309a529267bd2930c526adb2f1194d03ac3193ac1afa2b4e4f5129c92a03dfce5c9a82a8efa26bcab42db5d0bd27974cbf28d11a569d1abdbefdf12b6ff28aba484102edc074dd7bfee54be3ba9218191bc4e90801b50d0d56e9b2f5ba8beae227edc8aa589c297d9bcfb7b5b9ce5b6ac05f651c06dbf4cccd365365ab9f3fa7bb982adcfd26804eb118756ac00ad7964b9a69ddf5ba608551c35489be61fa88c7c14998c263d026467468a1f9a05a9a60c19723eb6bd41053d7676ab99f3d35d44d486156f79d58fff2143b187e8d97b3c1ecd235a2c00cb960a0002588b1bcc6b2903129c41a0ec21b25b54589a05b86238298f9534e58557f9a1bbce6760b459f6172a38e4d75fea8820442a37b0a2d635c697f780525624f627a47b66dd4c62b2452dfa129ebe06b5956de40c2cd1eba3ad96107294512eab7193d10ae79e30a011b110b1f472fb1cc25ca4bae4e64fb26f6b3e27ac07b520acf4f7574d3e155e4710cc9a90a80db2afad64990b61809521435640bde0d4550b4027ed37461ffc3b584dfc7b09d0a827ff541966c1845fd7db7ace2c859340d41ea841176fc295c5ac66472c2e511a53b1cb0665b63c614122a9c0c29bf459f73bc75243ba6ea09cb2ccd2d4970d28154693f4e63b41b743b3c5aec8464f536dd7d866aa91e84ede2450fc408bfc2481c0b839b35448cbb4d91f0a4dffd299d65d5e8e6eb9cd7289cbc7fd517627749db818112f7cadbbd75bcf52a3fc70479cd3231be2d18469a6cbc69b4a0f82bb9050b4afe1d306acc1b1aaa8d29f17154734ab81e13e9d32f4729b23f4d9d2a2259575dda8a6b7d20d713a408b2ad7c1fbd1fa5beacb5f6040bd232647b991f1ee66e4016f44caca6956657a03a5fc9755d4ae143c32a3becbc808aea42e41ff8dbbbc96063718ae2e3421a1ea5a16d3f359dcac8ff53638cd2120bf9c357e13572e9ffca7168009eda7c592a97110c5b73342dc153ba551eb08051579809eedaa4c4c2d2ad9bf6fe0e9782f0ed46382b39a29172cda52b66e804373ef7952d97c3402de57d5c73490b4cf9a002ca4094f9713fc9e337ee807b3796ecaeb9acc1df16efc901fa6546b53966f0b4fd33b81238fbb4484ca899b7b1faa13bf99ef9a8d1d8a9bd8004dad88e0010c4ea6818ff1283679d7ea6a6f905563cce53af8f2ec09c37176d400bb5e3bf1694ac65c61dad6ae510d7ea99e946567c95e5b5c303be055cf00178563205de3e9ffc64445d18fd3eeb54d002fb978578686db3853d0a68a36dc877cb0041cf80ee79804ddfacb6bc8df839a5bd6259e0af93951c85946565acdb59d003a721158a6917252e2e09a3d844380227f62d3b75bc21da9450de5772f7168e95136d247ea90aa440f93d7175c012904ca576b07458914827fe5ac717546028c1ce4de0179af93ddfd8ac065762c33ee510529e98e5d121162bb66edb81679a5e37b052fd7369683225c31f8ca89ddb848c06acba2a0ffb7d9adba8eab3f73eece7162bc27f8d46b9221863eac2cf0312a88709df923c6e3ad4ff6015c7f2a9b7149c8545c4d208e0387fe2074a6b5d3da6c177433ab17f17c0e0058c8425909527caf65b9db0a0344f616a86a11a0c1a6e801cb18419a39915c4fd9cc5cafaacd76e64b78e9d1d974f783fcfb2c932a26c30f08d3b052157060ff125213f5c60d03b3f75720e7785a5a7508b60666765e0d8cc873b097fbf2c03d59dec855744879666f758af8ed1a59efbc8f9a4757f9b3a5b2669ecccde2b0da7cfbdfc8e92972d919b79e5d35843ae25be7d7716799929bfaa8945ec9f48ec4b97fa2ba64074ae0019f0df009520e48702182a58e94e5eefef91d16b7efec0f11867b55e029391d8804c1c8813bbe32bd99d20fc80f9fcdaab435246b317675aa3891698974dc1c64e4e7e20cea256360cfb0d91d6c75d0ae601ae3b90bdd8260f4adde207230199f2dc337f068d299cbbc9441772c150ab0bbabb10e91f9b0cd9b006bc23c03f4b77c2a7d1a4179e74d894cb9627690a530062c80b183508c0bc33f7e2e1fe065e3d1916062685d21ec5d880824a3542d3530f713215e84499995f344ba6682eecd154b3820eb8c4f15e843722b4c2b9c68e140e728fdba1ec19ecd69ee3e7b67739e00dc150103dc3fb88bbc805e047174b20242e1bc8e308301dc17fe4d4585db4c92a4fd06357d06f27f0eb842c1ea28791e3cfa7564086a943a6e3303f9f980371ed74777b0f61878848e31414f835a03e515d7be66fa8381167d8a9afa827c3c0751b659b5aa472cfb5121105e11c03dd25f41c95ceda96d425a413624eeb258d77c5ac919a3d21e0494db70dbabfbc1af6a4cc717fff2cda0917341c0960c1708fe386464659df5f509c2eaf724a57d6848d70037e913f9cb01b19184b918f9cec8236f7cfea585d48b39eead05c65219b04f8a3482b1c024b72d8322c370d2aa8adbd24b8d6705e50bc995b400413c261e1d3af439c5458f4b127ff7334f3b0d108b4f5264d383d0deede6ffbb19269c14058e4354da1a1d23fafbd7acb0c896e0ec9ea2888ff870a16d7522f6640d9dadbbccf3453c312bcbde5c656a483ebc4dd0a1e1d1a4424c0028f2256095320ddaaeef7e4ac5aba580d63a0dfd8638f7372742de5dc4a125e1b96b01761b9003b7bf4d0afae43c2c805fbdc52528712cfe684f9b01b1c3ec640ba46d37b282c7cdf1b92c1e8a84d49555d228e9a4f9a15bc231a77986f76751e0f221543c654a09a4c26225b3916b84ad18f907a1b2fd1900f4aa698bc168f5221602ad4ff1073e8cc5dfe72bb6f676cfd435e3370ec2fdb6e149f3dc643e841db487ea89b90e646b83e707194b353f8ea3bfb3152c2c33ed5f34a7e2636267833797c48c1e7f0e0646627cb824a4119b622d83de70f842bc5da8951d104d53926fe0d00cc373b50b87a62ab43d88d19492ef1d2a33f9431a527766e82ff91f4eafef1b2b9ac20122a39381a3c1bc905087e09e3646947ae7b5ad70503b15fb7f7069fe4fa5bbd3c2c1f5ea1e35103f84afc9a8d6c762420a746bd8a1ab991318eab3e308f0ce52334a1d2a87def7240b551bab2160abab8bc636d9b82980f4fa89d7fb0f8fea2f2fae057f0afe1c95375c2fe96ebc32b249b86ea0bc7adff79ea2c150ab271824ed0b9c977708787079d9ee22ef4cd437ff8a8a65dae731fa285b648f20dc9f58e0a5c4b7a8e9896dc6255bcec81d1c9f7cad609ec5c5f8e93bf89b2de3500c64b3ea02f9f571d2219c4629d0b3bfdbecacb9c86681b82858e2fed9e8ce662d13bf4f401e636b77702de7ab9a9add1eaae2976a0bc52601c5ca7ac99804a7d5cf00bc423f87d45e05c3142e1bcd331f941ece768408e152314beb19e82f082a31389866c42f9b5b8558e1d4bf7d98c1b2bb867b6b37d671e334a977391a10a49208f1c66c827968d3f45161d36fb877f318f4be1229c4f00a92f895c7469e621ef370c7846aec4cb95bb3c418f78f534e1eb480093d4bfcd6a579951416d156231c65506aee1ad7d294a3e198cb3008a1d7952b6e76f6c4f1aea47da3c18eb1192dc8a491e936e8e7890fd1701cbf752ede2dbcd803d6fd15f9c2037f7db81ec21c23821838b97f6b220a9432b95bcab7f5e571e9fd287a95fc137af77db5e208f5e3d2fe90adc74af0144923545a0f211739f1ba4ba0fc18412bcc871640e9f32de53ae78625eb47df08cb175ae4a0e6131ce3dc0a0026a2e0770cba0bd959854270a98fec0b74565724e067739a748aaf44837f92df627d4a97631c2eb5d8cc3a1b1e5a0eb77a33b25107cd4e6fc16fd8ed7e96849296d4cb1b662ecf0e0c90ebc40781330948d9af33d05837685dc99d6f48df2f06f653ec889d7ae21ba4f5416b1736408e0990754039870801c38af0dfd5d53b85f8252993aa4ca90d8c2c1b566fc7f4fd37a00c3ee216d88931b3d0e2aedc2b8a0f1ed65bdf03a718d7c42f81b64602dad5eb8efa9460abd97f6a547c1d4c3897c431bdae57a4fa4633d1c7fb884bbd41a4caf6d3aa1fb06247a366bb10f0e3cb36e2ee09f6dd33c13bc9a613a9232c83baf32efcc11733246518c7169f9f14f2d27ceed338c5f20c6892a16cb3df6c0a853c2dbe027dd115a88f043e655327cf3d9f8986577ca622e4a48cf699ef5dc27ba88615a33841b081261fdbe5e3195361191c083861cfa313cd41bd6cc8539ffddb32970899d6b94138602245922321ca55087c0bec6a9038f6e9eb6a8d0125603d95563622cd9ea6a868006f1a515829f62ca1665c053b536a0c08488511950d70febfa1869e1e3ed2d97018e44c0550da4c29a7612d2ea963f19c2c7a2be8d0cc85ccfb9a3a8b3fb9dfddd2a237486ce3fabf6228cb462795fc17e80e5efef9222c6d5e1ef63137e6bad3b15c41a0adaa9ed9749e13f03c39c93c5d48fcb98028a03c908b1c0535c47ac339675f5f53e1f23be3970b481584e2137a4195d8575328dda881f5f57e1d7cad0533648e05d11f610b4c19beea0f941bdd25980f5a941b9bc1c03233058807a2a87af4b537cc7c2051b06de198f621b3fd4fff618cc873f7578876911742d773f997d0588307a468be69953abe7e8aa9b069602180f68f1783e17d08989bcb39cdf842d0da9d17dc86af414a085455dc735c49913ea7e222e66acb04b6055a67c5846a3ab42f95c1a86a9c82f11838e561c482bed7103024cf1bfa960dedac92014f082311fb9451f339987c5831b48c934dee2a3694c465b1c602c8cc978107e733461d4d4660bfa94d3df9150e949351f0b2292e4902609e2890265b89e3c64caca6726ca8d9fed23f481c5aaa6ef0a271e795d2803cef90444670319377f77dd1a9da40e661fb996363293727ac8ce0b6803d5ee539df1384bf51b50ea81f4fdee99e56261e832d176888679ee1411ae9c27a70789fd7f5909d24ae6fa890a290017094a31c5952adfa235c30d119abe0966ecac941d6a946fd142315d1268e275ba5d47583a6e265be22cea90fa71604f9b6d968f779fc78dc238dce0aacf029e4d833c4e6cf1c89a7362cf114e97ba148f02f3cbcc8184360dde845722a53afc9cf5489e03b746d6d1f8f1cde7209676b6959d2d587540566fa31ff36cac07eb9032b42c2d26a0a89243ad2b42eb66c6afd49db49cd53c98ea256063d17500d6651b87238c00461b55d70c442f6b260e705546047211349efbea62d7b2d55f36ce814b585fb50e6c8264937219851ff328f989d12f98e97f1d30fff03dbd6d174593eb3a0ef31da5ba14d080ac2c49c0cf0b796febdbad8c0e2bfb6e49ab312205357a5c8a549ba8290f27dd6bf27f74f275ee796ff670307162cfa868c781e344278ecf320099324b681794b98a89d437ff74f25f7cbf9dcafb646579aeb468203977bc35039ae1ea6cf7dfea04f78181ff21a3388b6447925fddd38c5e1c634cb44741a8fdfa542db6905a7bf1faa8b8a4d427a9f8ef24b8d793a03741dd24042293be6eb234a8034766fb19ed1d07e03e408e5793dccd1b58ce810b2bd6edca6a85975979d0ab39c2e9b764465355d84ced1cbe0b58509f9f7df6ffa6d103847306c361b0fa32d7cdf08eb1939b046dc18696d77c5bc9e92227d9f42a72d3c78e592bffc8af05b2779d680d2d7bded3669d5e0c9686bad21fa284d4fc524f1a5e9fa18eafd83676eb331abe7842151aa519ed801a69382597589b82c3d6a60efb480a1ea6533ec315d3a407a490a1bbf4197c04f3ea631e6aedb631143f32f881807cb6aa99577421e8d6d520a1da9297d2be0c465fc4602b97f3ab58adf99ffdb6e7a4cfd463ffc2a2f7ebcbfbde5806a698ae6f34d4c1bd4cd3bc7f062a9245a845e862646e5945186393d2e9edbb90aab722be680727843d5f4dacc096642be3fac4be0863599f2b6b6d816e2fa911a192cc93ebc0d2e0875a4abf30aaae33f0360d7c7f50a3b2947f7f927740b4b358f4a723fcaeed033731976502321e80f7f96e354c72e948f1397d1db34b94e63d899311ffa03157e9da82938ef531551f5321a0d9e33f6531dda5b70c1f158f9d2d08e4637c4d2c52e72ef3c58f011f0ab375d6a3a94622fa17b6140650e59b7f71fd6948003ac7541cb3e42bb4e8e79bc13effbcdfa41c55e48d85489e95f47405f3c56e9a804248311bdc1b7b83dbffe85e6c20d2a6ab34ddc801caa28c9e57159f06a6ffc771d0c6f0380ca21c8935b953879a58eac18b2ac754b947cf6eb0e5b6d9d48b8d448b7452f2f31f393f9e4a7e7bf811349d5c55c515aa8e34bc5c8c646ec796ba3cc7c53ddd465e10be90ae44b68e571836db3990604e7bf348a795f0a689194b4f68b7007e62e91fe936cd0fb09df364ac6453c9eb72c97756efd2b0cfdeaa84c52cb396129a463d1609daabb36aedea937bccc0c964a5310cd1575b349edb3446d2e99662d0627d663fce2f642cd675f7b09fbd21c564a928cbe2476862f9d2494a64f2e78e047c0c17cf83ade1282a7a8800e01f7aa95848d150bf4ac427f2ab3f4851bd516c175e3338311d5d67153962037ef73416288a199025371fe57557282e028398d2108b7c4f359985d38caae104dacab86dc12f4d2232cb3913813b108d85c8f260ac3fff35a8d378e15b97cd7c8f9871fb25710ba1842148c7afb606fbd59b418a27e1994c77c4f89e9ded7cea11cd951180d7b3860deb89a6c96ac8023e03577a77bf1f67106d250a752c0b35d41096bbb43bf367a8ca3d5a4488fe6b0019b889e25e0bb4e91adacf8358fab09a174b245ba6d47a0e1db698324cefb4f8ee62f93efa4f6b66bb20bf96482b6c19be61ded97f64c2519e290c035bf6c42e545f322fd6245ab2fa0efdac64fd213cb31561cf09761f6b8750c9adf7fe5305357cf94115a3e514c4e7ceda59e085d5893b421a9bdde862f799a9f172d23a94e38e13e1ba0b88c844594206e912b42206e55433e38fde8172c05e42f27f280a2e3b89afa920e3b835e306f44f9c7c0dee808e8018ebeea596f0ef864dd9392c81a05aec1cb823dea4d1689087236e916f45265c3f54d7d7c424a82e4a0f25893e81e59b3aafd4fed7d0fac73e145c4c73058e2821200f40a5d5231fc51156a0e58952ec56720013d369503065905cecf8d8290898e08bd5d82ec66f42e8e32dfb23f79998e9b6a0cf402c678cc2bc0d7147b368fdd72302933bb402eee60b69fcb9e52e88ab2d710d540d38b08f9e74fe2b96aa33b7b9d2091706a0f9f66a34acfa5f8a776214633c38d1a1f951a26392916c406f0e2440fea2b8686263ec8aca7d7de7fbe3d0cc6e7013726bf0c651c75e3bd09e556b02a55d48f9fca0395e5c53933de09ae693eecddc761c464b55c535dcfca9eb4d3eb2af3ddeb0c33712bbbe64aa8e075a5bd390af4fa51248d77816b35bc88bc9afb907835e56c1607a783c87c5b2dd59d8c7c3fa8fd156a724665d238475f5a137b0c878303b5dcde5fcfb97488c9e3b09151cce16713862b1263046a13790f9cd7a07af6b5640f47b1e2aadf04dc2e7eb1f683b1a7b800159aa27de76bf799ed14be3d640ffaa1f25e28801d1847ea5462ad17faf2c335287932f391b27a6f1213b4e8a4b10761018fd0c1b5171f5f108d0eb6ff053cba30f747ff1e2819fd4896a31e25d4401ff3c3f5b1d9b7779d214a2d69df3f203f5d6360af499acf54540a6e5a6b334bc989005b2e34dbd0e894e9fad49a820f810d42ba3de38c86c8e896ea88c4bc18e54a28a03e01667bf6eee914619959168b2310f876897a2dfb7888512d2a3b12c292d0d8d8a12b6a7ac3c70fb0421e623ec3b7fde9b8417b8aab6c07ab847440da5da75fba7c80c78ef21000b043ab9b11dd6152a5994af26325cb0d02197ec0df0ef101b2c7facc95334fe0f544db8f9e3626fe742c9204799b2bacd32b3ed161a901810949362a50c3d5ca422fb8f99f64e0331025da5c9c03d8796e9e28df9ee585efa026cb27f9bdf14f54d0d345f6765b3f1c77a166a064f3b8c396ad4f33dafe34440af6e2b64e3f2456d7be4891caaabf61fb30c00918037e03af0a58a42e74e62526138f8ed6c982ca9327a5634f4d9cec3aea2ff27cd1a30b58fc01d95178f9d3ca89b9a1de9f8ebe0c6882bf385fbd390037b03ceee6684a1b7dc24178710fdad04622883a42ff82912f16d27513bac8df1b4ac1e8ca8811d53ffd2fdf4fd7acec921d1a2721ec331225d0a01d873a27ccd4b11524e720fe1773009fd9cedfea85151c385cd4d24271c633d6f0cbdfee2824c214164df5a85e2f6e1520f5c806e127ae148b891e4fdd9d4b904f0c53d9878bb0efb3c5b789a8a38ac1619b1b68cc038f2494c54ebc6f67ed512b279b1040faef3b2fa47174b274da09b50bf736766a38b9cb99c9bf2259ecffda09c971fd06db7212723a4a831411f70a6166dbe8b0b84b660ac157a155b642f4cb70f90f7da33d5e891fbc9d05ca6bd5de0b4913b6305a95ffda8e76ba37fb8286cc36c50b3ff076f9d8cf0af83aff7bb1f3188c94dc43b8aa09a1cc6813938581f82455f9c5c2617ae3b21a662d982f1fa127c2a9d6bff1914c2ea2e0be7a20ef5e88c19d11833577657c6a18dd6684248f7604a72cedab78602863fa2f72e8793abd1462e5b0e7f19aec68ccc61026158a20626308ed2f3f06536801698a2da32e43d8ee4df8e557292fa442337a6d84093cd1fb3c7f1877259ec13fa6f64121f7386f25e0901b49fd521c464301eccd4190e7a535c073696ce54d1ef8f3c1321408c2985a1d17fe8c6aebea4c95f2da31e79d249ff11f03664b4110fd3280c885a65b2eaf3a1f3b61df03d6b7926db476e92a7c4d192001f9257d65ba1e684b4cde2f40516523467ede2b020d9a54a7ae8716affef806a2c59eea912d2e64de36f870c6f75078d67eebdddc507115e233d1e23dd80ea1913f2d12c7c152270319f04bc584c86e6e4d624ed32802b3c23a25d15f50750cf2405182b5c1d1e0df26b32cfab5a5c5ce281cfb53eb63317dc3d0ad080bb3425ede0c9cc9f003ea80841b85683c827f6c4eb25509415d6254ce770ef8d349ff03e30f55c1422925d44e752a02dbcecfa421d1c096d0dd7d93fa658f0b42bd510c908fa15d4e8044578dd08c04fc8d8153b0eaddc63ebff91e8c2ae4b6c694e973f8c474346cc858e55c338e3be287c9f121d764843fb9ea147549ca208c0730a5ca6a491baa09efadeb5e3752d80f121fde8d3cf8cbf8b6768f8365087082b430ce82bf100ce398ce2fd585c75d15b491fb75adf97f2db98446d557b74ad97c7896bb96f5893743bab7032e17267d6db2e91b724a95b5382baece5faeb59985234054ec47d0610e94ea8f74e4b0a6ebdf5c8712391e99d3a4b43d778657fb7a2e967921d1aa38694fd2c111c3b1b8d92cfa167cc5adc03e511315a8e2f477828788218de43c096c3af84f2496fb8d960237ae9d7553b03fdb9c7a2d778a3a77495b831c7d196a8baab08d85fd0c96e677e9993b9fea9f7a97ecbbdb960cb61008b227c1a7ea458173376abf379d2ed84518fd5587bdec3ca8362d210385f2a3bb2470aca79284f4a634aa0f28617143c40d5648f85db59c74c7bdffe5efbf548b70b9895798b0c236296d7f69b7cf49af320d6743e6073e562eb178f7a8ab52c1fce6f72fb5c6a57d2233108df4be6e93983d7c4407bd5d823ddecb65471196bfebeb6faa5db306635408777d3b41dff09b77da7ddbacec726946290e7408f7404c9df183d44fb2a06e887866b89b45660366e93f63bc959329093b8bb3fc9202daf6f237f43734833d09a8f91744f25799a097ee51870492d1e6acdf9d2d91abffd60c06c59cda1138348b954d51b9026c3f5f9b2320c32447643a495f197429d097e0f33390ff8491b7b06110c50f7a3aa1d6c10f85c873cffaaef3d88e32c9ae986cb423222f238d83714d29b524494e3b937d580dc5b347fca429d4a10ee79409a2c8a566e4b9e8f9f1afe6f06a8b8f302509aa1c1dad0a317edd90f5282826c648cd3c931d7b297bc10e2f513ea9c373b5ae42449ceeab2788356f6cab536a2f44a82ba79480389d38265438dc08fe9e67224b3573b5f4b75b9d7a29020730627050b44a4009c175395dede1972a262192a06a892ffa9fbbfd7de34d46bee99c96ba9c8e47a01252054856ba915ff5f6618c0aa5744e9fb53fee7646b5a3fa9a67d0b168d34369571ec8bf3bef725bd0669644d9d33bde674a13fc657efeef2860094f389a17afb7cd548590c34af39a16136e2dcf237eb22dae2e8798ffe4e2fdb9a675db66bcacdd6f65429658db22b5a3186b064621dd25c73e4391b7c1fac1d5e690749dabc192f80c127d3687560d7da043cdb654fd791e3223337ca88da5bb23efa2712110b4ac86953bf8d229d2069832cdec1fdd9838b6ea19843dc021a1c0cc24fd97417217412cabf087fe3920d3f4ea971fe51dbe4cd90c49304c3b84625d7ef5f18968a3a60f4b98ab1c335013358d2e0f09e55161e79b64dcd3dac630f602a0b7b95b767e2c8d15767811922da75a7d5e9e0c566cd4a9b069427c341c7acf8e4d7c67785f27ec8bfcf4271b24b15c09adfc18f7ed9aa53f7fead31ed5e808f00a9ca43ceb7219ae183dd3c93893495039b7f955966e34ce1b8ed560b1b0bf3a45e7bb33ddf84ea0a3c3dd3256b10fbb8378cabf1870edbc2db4ea37b3a108e27aaad3765f8734c5b30d9e9ca6a891b9303ef65814d870a3f1f6097c9a07f90b9a65c40d8498d1896d8d248f289d67e80c6cc3b19f06e3f45f4c39ec71170bb1dca2cd1bae96399b5fb2477333c888aa578118ef175472fc0520b7005e160029db63ad0ace5414ea628da288c5a6041db37a34c8c6086e98dc3b0b9a60aeabb89f1b0940fcce8c77bd2e1eb2dff637a157f721a44ba980dec81b8321c2b03689e8c78cfa9049e3b7789eec1bf6583cb9d19ae49d0a5cfffd6e1f385a26373a503bbbc43c54d5b74e283fedcaac8fa95e3072baae964d83f2a09e31225d5fd14d99a9caec00c34a21faef79ef3b358e2dba3c5c644eb0b53fbfd350de6b2131222a24c231e1a47ebb9cfa2ced88eb6ae908720f2658d533897f0dabf27a808630427bd485e13c98904df3744197dfe8839923aeecdf2a227320d2c30a3f06a756f0e22bc3971c3a8bf908675e0321f5c7e40888aa92994be3287140979de9ef1ca8d7f0b7adc8b27df5f1894b943259673667fc4737fc132d6a0abfa901e5751b0ad6de799e42b9adf73934cf945bfcac3d1340607e937a4a18ae51d9a289f0c3db0dc504af0e7a9a77a7f97a21c1df5ff9c77e0000e17181b74691fb006e58373802c33a6fe7bf6940b8bc7e131bda665dc485715a5548e8ef476c0981ebcf6abc51aebd0dd03dac63da2fc1d92e57d43f01ce66eaedb16671f9853606fc2eed792071348b1f4fcb91f875561d226fa4b87482efdcf1034484bbe96519699069910437c8b912034c441b429f0ed8474e55c778b82da493cd7836818f907e2a94193258ec9153be00ae7375065fe2ef5470865d834472bbd801bc7e661f6f2939b7a2cbf824c63f940cbc916c2756a79021a88ccc67c4245aeee7ce9c52697cd8e81cae30d890d987d952e47fce9c72767188a0b08a45fa97762626b545fd519adc3c536f581253a96462dcfae4d544b8b2be6f8d0d4f9205e2958a7e2e68c805b148d053f3dbd8f78735bb601db0ef8761d33bbf23b57314f5784c60f02bd96cf6b949b96febc51cf00cc41418abc09e81be38fba0f384d792450bbce58f7b6f6f45dbca33d9d4567db8bbd0878bdc8b0011de677ee923e224f08df56969edf8cb086c45676460d584df78564d5da9ff1518a7526abdf143aeceb8cb6100bd4208eced0bf65515573f87683fc10349f083c97a9db669cb3546771ad20607f419ce883b9b8236c90a206f47d1681e4b11a3704fdf03ee634056e5fa8c1aaf69c4971b5129ca28df9e6322f9809e034f6fc4fc5ccc70ce8f7e551d9f4a954b6d7f8bca82de521892e69bdd457f32d716ffb77075ad3e26e5ae1af4065de860c7910f895a7d3443cf85b8aa3b3f8163ea49bda47aee227303efd5c488e496f614ca553e5db57ab8f0d902baef58d594bf38a59d1d4dfa0822339dd240633df78a1c51134a21bc16390d6e168d612209b57e9ff9c0a57324488b19a3f43536905f29b305be690f69ecad134cb47c855dd9d3d2a6f3732b1940fe3db10e08f91110a52db4f04063b4a6d999876cdd6110fd0522be763192f7246a26476ac40882bbf388c161b2c24ff3227b026246412dafe2c30af0508103793d24fc7e4f3b3365286bb11fd141f14d7f73857cb41621ce67b8a0c9dbbbec95777ad2fa3261786e5cc5a7e045017a5836d09280c20459c29d0957b1574635448eb144352e13c94d489b662dfaad968dc5969e1d5f5565800e05091dfcd1cf1dce4458293e0693c1e1b75904efcdd8c3fe12ba35849291366075ff57c39dbad51072afcc3898b5ab1e571920ce85ee142859a21171f33a6f03be6af28062ba7aad713ba7d0396a990ac1944d4b8f35d467b8172ed0013ac29094a1400f42153c925a901f929975825c1f06916a417955fa02c24a0eba4578527dfc9b693a9d3a68af9feeffe78d7b2c8a64e26aee36fe067358adfaf2e1a2e91b837f7ed8e545614e4dc2225dd59d6a431f565a378687abffafb00443a11441ae3e5b13bf8b545f1a24459240c68c20a47941144ece001eea7aa1af10ec411cce1540720a5b30a8ef6999862f67bb759df5d3e8405305d26fe1017737fbc93bee53097f32e0e78ba916c268f580a86fd210177fa35dea4d10aa0a74e5b9f7c8a83c8d6b9469493ab51f628513344a75ce7c529c72b92d142b813433ac89a98beae418ad00a52393bbc6428a728f85254078fcc6ce719404563823f9e070da3c00f38e6be514c332778cbaf78cfa069590bbec95901616a363fd49e04aaa610a677de697907bb7a0f5359bb42458133edd5caf0d1cb03580a91bd2b3c492487e22e744329696abaafa99a9959b3a5791e6dc1b2c2716db7e8da9f79d715d7b88c0f111b5bc3459b68dcac877d45b96fb1b660e9738c7d9b8e7c4d5c49fef91377866e0bc23e57432a089558d0b7f22d28d0b1970aeba2beaaed0980e689bb26fe9c63dd3d54aeb38784feb8d6a159f6470f48fd6880de06c296ddcc6a400a43ef4ec8b76bcd5ffe8950d4c91beb1dd935c5715ac77357e026970ddb291c9a152f7910b2b6cd0cbee5faf5fb7003739f7adf2835992c168cc92e037f1ac1ba2482343b69bbd5835b54229919da8f3f852bcb8a18ebd0c72680e98e53b0465b7a092d9664cf71fbea5a83f38bef4d055e0f1987ec4600282df0f2a4226b9e1e8f8bf9030512fe55c8dfddf8dfedde024cfdeb1ccf7cd32cdffb061de55e6c8c8d100ae1035ce8f043d45533f0533c3d89aecabd37dd01af872b2e63e556aa53f1f0825b9b7e630b9854b524f79c5ef7944bb8905c211ebad5589bea8f86e35fea67d3a66bf01db673fe22cd248932d96c511f49bf997ff00699e6876f045c79a555735d607bd10171d0a5408b6e96a93e113d1fdf01943871da0931bbad5aad88fafa8e1aaf3016335e74312ee4798b259bcb3abd13777778b72e90d4b23f6acd67d4ecd83988e63cc1a0e833c4dddd48b035b5c5a6c404eecc02dccc3a19029bde8efa1f1e242a85dcb441faf990fa403f361e20484fc9e72a40b6e2424f5e14e24f6f86a041489ca54782a88ad496d41f525d8e8b31b50a5cbe80f5279cf478f62b52ea2d2e84f5c04558c2afadbf1bc7258d14d372dcf91d957f873fdf1d48c0e57670b82c122d1db4c47da0d04880385d8a2d27442cb81e5815b81f62894fcf70299593bee56da0130e52f1a383611946c910357b995a5288905fc78304cd7fb93473d1dec98c3c20b2226251608ee8c58339579832cc045e595818a529f8a62e37a98bf9dbbef0d84d5b3bc49ef8c41baf70368bc02c36b3b48a3861a5efedd4356b7e632e6329b83eee976b2165e806bdf03bee869311dcadc444fe7a82138ddfb7e506c3d7cb03ed06742255eb53e70feefb2a5fb15296e5a138d5434d9f6f2a97060cf678470cc770d338dd1a384f6e51d2c9f338b83447b5d6ca53213efef10cc2aafcc8797436fe758f09e72833997fab99d345600c9013e20248671d32d97023d3986a2f495e00b2c7fb37ba1cffdc7682b24f39f7a5998a8b0c960379c16c6f26f74db1b63d4aade0ee5f07b390ac72e2d7a212a0b49521bc34ec000fbc95e79764f2eeed2c3bb2cc7433ca45441b82455ee479d473cd918fadaa279e6ac2d5e6197f181d0d2cc334fcaaf7e12f7cdb7e36434b380d25dc85d3fcaf900832c07b55b22e5fe79db4c5d1bf3e81c9d39dd9dab0c9cec902a7a8bc0245499f0288d8ea1469c730b522e251bbb7bbefa2b38d23c3024dc602ed5076e47059fa789c5d6aeb90f6bd661335dfc724a12838ab51f6aad0b455c21b3705735101c18d784c99b5521f39774fbcdda0ba71eff9d25095b8f6f1cb5e1ac751ecf45cb0d734f8c8a1e49373b088a2e75016a7e891000cbaa04697e9456b0bcdef90df53028850faff304834df","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"65683c00ae5e994db758ba32503995c0"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
